!function(Q){var n={};function B(F){if(n[F])return n[F].exports;var t=n[F]={i:F,l:!1,exports:{}};return Q[F].call(t.exports,t,t.exports,B),t.l=!0,t.exports}B.m=Q,B.c=n,B.d=function(Q,n,F){B.o(Q,n)||Object.defineProperty(Q,n,{enumerable:!0,get:F})},B.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},B.t=function(Q,n){if(1&n&&(Q=B(Q)),8&n)return Q;if(4&n&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var F=Object.create(null);if(B.r(F),Object.defineProperty(F,"default",{enumerable:!0,value:Q}),2&n&&"string"!=typeof Q)for(var t in Q)B.d(F,t,function(n){return Q[n]}.bind(null,t));return F},B.n=function(Q){var n=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return B.d(n,"a",n),n},B.o=function(Q,n){return Object.prototype.hasOwnProperty.call(Q,n)},B.p="",B(B.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/styles/index.scss\n// extracted by mini-css-extract-plugin\n\n// CONCATENATED MODULE: ./src/scripts/utils/keys.js\nconst KEY_CODE = {\n  TAB: 9,\n  ESC: 27,\n  END: 35,\n  HOME: 36,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40\n};\n// CONCATENATED MODULE: ./src/scripts/tabs.js\n\nconst SELECTOR_TAB = '[role=\"tab\"]';\nconst SELECTOR_TABS_CONTAINER = '.tabs';\nconst SELECTOR_TAB_PANEL = '[role=\"tabpanel\"]';\nconst SELECTOR_TAB_LIST = '[role=\"tablist\"]';\nconst CLASS_TAB_ACTIVE = 'active';\n\nconst Tabs = tabContainer => {\n  let tablist = tabContainer.querySelectorAll(SELECTOR_TAB_LIST)[0];\n  let tabs = tabContainer.querySelectorAll(SELECTOR_TAB);\n  let panels = tabContainer.querySelectorAll(SELECTOR_TAB_PANEL);\n  let isVerticalOrientation = tablist.getAttribute('aria-orientation') === 'vertical'; // Bind listeners\n\n  for (let i = 0; i < tabs.length; ++i) {\n    addListeners(i);\n  }\n\n  function addListeners(index) {\n    tabs[index].addEventListener('click', clickEventListener);\n    tabs[index].addEventListener('keydown', keydownEventListener);\n    tabs[index].addEventListener('keyup', keyupEventListener);\n    tabs[index].index = index;\n  } // When a tab is clicked, activateTab is fired to activate it\n\n\n  function clickEventListener(event) {\n    let tab = event.target;\n    activateTab(tab, false);\n  } // Handle keydown on tabs\n\n\n  function keydownEventListener(event) {\n    switch (event.keyCode) {\n      case KEY_CODE.END:\n        event.preventDefault();\n        activateTab(tabs[tabs.length - 1]);\n        break;\n\n      case KEY_CODE.HOME:\n        event.preventDefault();\n        activateTab(tabs[0]);\n        break;\n      // Up and down are in keydown\n      // because we need to prevent page scroll >:)\n\n      case KEY_CODE.UP:\n      case KEY_CODE.DOWN:\n        determineOrientation(event);\n        break;\n    }\n  } // Handle keyup on tabs\n\n\n  function keyupEventListener(event) {\n    switch (event.keyCode) {\n      case KEY_CODE.LEFT:\n      case KEY_CODE.RIGHT:\n        determineOrientation(event);\n        break;\n    }\n  } // When a tablistâ€™s aria-orientation is set to vertical,\n  // only up and down arrow should function.\n  // In all other cases only left and right arrow function.\n\n\n  function determineOrientation(event) {\n    let key = event.keyCode;\n\n    if (isVerticalOrientation && (key === KEY_CODE.UP || key === KEY_CODE.DOWN)) {\n      event.preventDefault();\n      switchTabOnArrowPress(event);\n    } else if (!isVerticalOrientation && (key === KEY_CODE.LEFT || key === KEY_CODE.RIGHT)) {\n      switchTabOnArrowPress(event);\n    }\n  } // Either focus the next, previous, first, or last tab\n  // depening on key pressed\n\n\n  function switchTabOnArrowPress(event) {\n    const pressed = event.keyCode;\n    const target = event.target;\n\n    for (let x = 0; x < tabs.length; x++) {\n      tabs[x].addEventListener('focus', focusEventHandler);\n    }\n\n    const direction = pressed === KEY_CODE.UP || pressed === KEY_CODE.LEFT ? -1 : pressed === KEY_CODE.DOWN || pressed === KEY_CODE.RIGHT ? 1 : 0;\n\n    if (direction !== 0 && target.index !== undefined) {\n      const newIndex = target.index + direction;\n      const activeIndex = newIndex < 0 ? tabs.length - 1 : newIndex < tabs.length ? newIndex : 0;\n      tabs[activeIndex].focus();\n    }\n  } // Activates any given tab panel\n\n\n  function activateTab(tab, setFocus) {\n    setFocus = setFocus || true; // Deactivate all other tabs\n\n    deactivateTabs();\n    tab.removeAttribute('tabindex');\n    tab.setAttribute('aria-selected', 'true');\n    tab.classList.add(CLASS_TAB_ACTIVE);\n    const panelId = tab.getAttribute('aria-controls');\n    document.getElementById(panelId).removeAttribute('hidden'); // Set focus when required\n\n    if (setFocus) {\n      tab.focus();\n    }\n  } // Deactivate all tabs and tab panels\n\n\n  function deactivateTabs() {\n    [...tabs].forEach(tab => {\n      tab.setAttribute('tabindex', '-1');\n      tab.setAttribute('aria-selected', 'false');\n      tab.classList.remove(CLASS_TAB_ACTIVE);\n      tab.removeEventListener('focus', focusEventHandler);\n    });\n    [...panels].forEach(panel => {\n      panel.setAttribute('hidden', 'hidden');\n    });\n  }\n\n  function focusEventHandler(event) {\n    let target = event.target;\n    activateTab(target, false);\n  }\n};\n\nconst initTabs = () => {\n  const tabs = document.querySelectorAll(SELECTOR_TABS_CONTAINER);\n  [...tabs].forEach(tabConatiner => {\n    Tabs(tabConatiner);\n  });\n};\n// CONCATENATED MODULE: ./node_modules/tabbable/dist/index.esm.js\n/*!\n* tabbable 5.1.2\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\nvar candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])', 'details>summary'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar matches = typeof Element === 'undefined' ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable);\n  candidates.forEach(function (candidate, i) {\n    var candidateTabindex = getTabindex(candidate);\n\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate\n      });\n    }\n  });\n  var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function (a) {\n    return a.node;\n  }).concat(regularTabbables);\n  return tabbableNodes;\n}\n\nfunction focusable(el, options) {\n  options = options || {};\n  var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable);\n  return candidates;\n}\n\nfunction getCandidates(el, includeContainer, filter) {\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n\n  candidates = candidates.filter(filter);\n  return candidates;\n}\n\nfunction isNodeMatchingSelectorTabbable(node) {\n  if (!isNodeMatchingSelectorFocusable(node) || isNonTabbableRadio(node) || getTabindex(node) < 0) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isTabbable(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorTabbable(node);\n}\n\nfunction isNodeMatchingSelectorFocusable(node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node)) {\n    return false;\n  }\n\n  return true;\n}\n\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\n\nfunction isFocusable(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorFocusable(node);\n}\n\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n\n  if (!isNaN(tabindexAttr)) {\n    return tabindexAttr;\n  } // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n\n\n  if (isContentEditable(node)) {\n    return 0;\n  } // in Chrome, <audio controls/> and <video controls/> elements get a default\n  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n  //  yet they are still part of the regular tab order; in FF, they get a default\n  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n  //  order, consider their tab index to be 0\n\n\n  if ((node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO') && node.getAttribute('tabindex') === null) {\n    return 0;\n  }\n\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n\n  var radioScope = node.form || node.ownerDocument;\n  var radioSet = radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n}\n\nfunction isHidden(node) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n\n  while (node) {\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement;\n  }\n\n  return false;\n}\n\n\n//# sourceMappingURL=index.esm.js.map\n\n// CONCATENATED MODULE: ./node_modules/focus-trap/dist/focus-trap.esm.js\n/*!\n* focus-trap 6.1.3\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\n\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar activeFocusDelay;\n\nvar activeFocusTraps = function () {\n  var trapQueue = [];\n  return {\n    activateTrap: function activateTrap(trap) {\n      if (trapQueue.length > 0) {\n        var activeTrap = trapQueue[trapQueue.length - 1];\n\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n    deactivateTrap: function deactivateTrap(trap) {\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    }\n  };\n}();\n\nfunction createFocusTrap(element, userOptions) {\n  var doc = document;\n  var container = typeof element === 'string' ? doc.querySelector(element) : element;\n\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true\n  }, userOptions);\n\n  var state = {\n    firstTabbableNode: null,\n    lastTabbableNode: null,\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false\n  };\n  var trap = {\n    activate: activate,\n    deactivate: deactivate,\n    pause: pause,\n    unpause: unpause\n  };\n  return trap;\n\n  function activate(activateOptions) {\n    if (state.active) return;\n    updateTabbableNodes();\n    state.active = true;\n    state.paused = false;\n    state.nodeFocusedBeforeActivation = doc.activeElement;\n    var onActivate = activateOptions && activateOptions.onActivate ? activateOptions.onActivate : config.onActivate;\n\n    if (onActivate) {\n      onActivate();\n    }\n\n    addListeners();\n    return trap;\n  }\n\n  function deactivate(deactivateOptions) {\n    if (!state.active) return;\n    clearTimeout(activeFocusDelay);\n    removeListeners();\n    state.active = false;\n    state.paused = false;\n    activeFocusTraps.deactivateTrap(trap);\n    var onDeactivate = deactivateOptions && deactivateOptions.onDeactivate !== undefined ? deactivateOptions.onDeactivate : config.onDeactivate;\n\n    if (onDeactivate) {\n      onDeactivate();\n    }\n\n    var returnFocus = deactivateOptions && deactivateOptions.returnFocus !== undefined ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate;\n\n    if (returnFocus) {\n      delay(function () {\n        tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n      });\n    }\n\n    return trap;\n  }\n\n  function pause() {\n    if (state.paused || !state.active) return;\n    state.paused = true;\n    removeListeners();\n  }\n\n  function unpause() {\n    if (!state.paused || !state.active) return;\n    state.paused = false;\n    updateTabbableNodes();\n    addListeners();\n  }\n\n  function addListeners() {\n    if (!state.active) return; // There can be only one listening focus trap at a time\n\n    activeFocusTraps.activateTrap(trap); // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n\n    activeFocusDelay = config.delayInitialFocus ? delay(function () {\n      tryFocus(getInitialFocusNode());\n    }) : tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n    return trap;\n  }\n\n  function removeListeners() {\n    if (!state.active) return;\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n    return trap;\n  }\n\n  function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n    var node = optionValue;\n\n    if (!optionValue) {\n      return null;\n    }\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue);\n\n      if (!node) {\n        throw new Error('`' + optionName + '` refers to no known node');\n      }\n    }\n\n    if (typeof optionValue === 'function') {\n      node = optionValue();\n\n      if (!node) {\n        throw new Error('`' + optionName + '` did not return a node');\n      }\n    }\n\n    return node;\n  }\n\n  function getInitialFocusNode() {\n    var node;\n\n    if (getNodeForOption('initialFocus') !== null) {\n      node = getNodeForOption('initialFocus');\n    } else if (container.contains(doc.activeElement)) {\n      node = doc.activeElement;\n    } else {\n      node = state.firstTabbableNode || getNodeForOption('fallbackFocus');\n    }\n\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n\n    return node;\n  }\n\n  function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus');\n    return node ? node : previousActiveElement;\n  } // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n\n\n  function checkPointerDown(e) {\n    if (container.contains(e.target)) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n\n    if (config.clickOutsideDeactivates) {\n      // immediately deactivate the trap\n      deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus: config.returnFocusOnDeactivate && !isFocusable(e.target)\n      });\n      return;\n    } // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n\n\n    if (config.allowOutsideClick && (typeof config.allowOutsideClick === 'boolean' ? config.allowOutsideClick : config.allowOutsideClick(e))) {\n      // allow the click outside the trap to take place\n      return;\n    } // otherwise, prevent the click\n\n\n    e.preventDefault();\n  } // In case focus escapes the trap for some strange reason, pull it back in.\n\n\n  function checkFocusIn(e) {\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (container.contains(e.target) || e.target instanceof Document) {\n      return;\n    }\n\n    e.stopImmediatePropagation();\n    tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n  }\n\n  function checkKey(e) {\n    if (config.escapeDeactivates !== false && isEscapeEvent(e)) {\n      e.preventDefault();\n      deactivate();\n      return;\n    }\n\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  } // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n\n\n  function checkTab(e) {\n    updateTabbableNodes();\n\n    if (e.shiftKey && e.target === state.firstTabbableNode) {\n      e.preventDefault();\n      tryFocus(state.lastTabbableNode);\n      return;\n    }\n\n    if (!e.shiftKey && e.target === state.lastTabbableNode) {\n      e.preventDefault();\n      tryFocus(state.firstTabbableNode);\n      return;\n    }\n  }\n\n  function checkClick(e) {\n    if (config.clickOutsideDeactivates) return;\n    if (container.contains(e.target)) return;\n\n    if (config.allowOutsideClick && (typeof config.allowOutsideClick === 'boolean' ? config.allowOutsideClick : config.allowOutsideClick(e))) {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  }\n\n  function updateTabbableNodes() {\n    var tabbableNodes = tabbable(container);\n    state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();\n    state.lastTabbableNode = tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();\n  }\n\n  function tryFocus(node) {\n    if (node === doc.activeElement) return;\n\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    state.mostRecentlyFocusedNode = node;\n\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  }\n}\n\nfunction isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n}\n\nfunction isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n}\n\nfunction isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n}\n\nfunction delay(fn) {\n  return setTimeout(fn, 0);\n}\n\n\n//# sourceMappingURL=focus-trap.esm.js.map\n\n// CONCATENATED MODULE: ./src/scripts/modal.js\n\n\nconst BODY_OPEN_CLASS = 'has-modal';\nconst MODAL_OPEN_CLASS = 'modal--open';\nconst DATA_MODAL_TOGGLE = 'data-toggle-modal';\nconst DATA_MODAL_CLOSE = 'data-close-modal';\nconst EVENT_CLOSE = 'modal.close';\nconst EVENT_OPEN = 'modal.open';\nlet activeModal = null;\nclass modal_Modal {\n  constructor(modalID, toggles) {\n    this.modal = document.getElementById(modalID);\n    this.focusTrap = createFocusTrap(this.modal);\n\n    if (toggles && toggles.length > 0) {\n      this.initToggles(toggles);\n    }\n\n    this.eventClose = new Event(EVENT_CLOSE);\n    this.eventOpen = new Event(EVENT_OPEN);\n  }\n\n  initToggles(toggles) {\n    [...toggles].filter(Boolean).forEach(toggle => {\n      toggle.addEventListener('click', event => this.showModal(event));\n    });\n  }\n\n  showModal(event) {\n    activeModal = this;\n    this.activeElement = document.activeElement;\n    this.modal.classList.add(MODAL_OPEN_CLASS);\n    document.body.classList.add(BODY_OPEN_CLASS);\n    this.modal.focus();\n    this.focusTrap.activate(); // this.hideAllContentForScreenReaders();\n\n    this.addEventListeners();\n    this.modal.dispatchEvent(this.eventOpen);\n  }\n\n  closeModal(event) {\n    activeModal.removeEventListeners();\n    document.body.classList.remove(BODY_OPEN_CLASS);\n    activeModal.modal.classList.remove(MODAL_OPEN_CLASS);\n    activeModal.focusTrap.deactivate(); // this.showAllContentForScreenReaders();\n\n    if (activeModal.activeElement && activeModal.activeElement.focus) {\n      activeModal.activeElement.focus();\n    }\n\n    activeModal.modal.dispatchEvent(activeModal.eventClose);\n    activeModal = null;\n  }\n\n  addEventListeners() {\n    this.modal.addEventListener('touchstart', this.handleModalClick);\n    this.modal.addEventListener('click', this.handleModalClick);\n    document.addEventListener('keyup', this.handleDocumentKeyUpEvent);\n  }\n\n  removeEventListeners() {\n    this.modal.removeEventListener('touchstart', this.handleModalClick);\n    this.modal.removeEventListener('click', this.handleModalClick);\n    document.removeEventListener('keydown', this.handleDocumentKeyUpEvent);\n  }\n\n  handleDocumentKeyUpEvent(event) {\n    if (event.keyCode === KEY_CODE.ESC) {\n      event.stopPropagation();\n      activeModal.closeModal(event);\n    }\n  }\n\n  handleModalClick(event) {\n    const closeAttr = `[${DATA_MODAL_CLOSE}]`;\n\n    if (event.target.hasAttribute(closeAttr) || event.target.closest(closeAttr)) {\n      activeModal.closeModal(event);\n    }\n  }\n\n  hideAllContentForScreenReaders() {\n    [...document.body.children].forEach(child => {\n      if (child !== this.modal) {\n        child.setAttribute('aria-hidden', true);\n      }\n    });\n  }\n\n  showAllContentForScreenReaders() {\n    [...document.body.children].forEach(child => {\n      if (child !== this.modal) {\n        child.removeAttribute('aria-hidden');\n      }\n    });\n  }\n\n}\n\nconst generateModalsTogglesMap = toggles => {\n  const map = [];\n  toggles.forEach(toggle => {\n    const modalID = toggle.getAttribute(DATA_MODAL_TOGGLE);\n    if (map[modalID] === undefined) map[modalID] = [];\n    map[modalID].push(toggle);\n  });\n  return map;\n};\n\nconst initModals = () => {\n  const toggles = document.querySelectorAll(`[${DATA_MODAL_TOGGLE}]`);\n  const modalsTogglesMap = generateModalsTogglesMap(toggles);\n  Object.keys(modalsTogglesMap).forEach(modalID => {\n    const toggles = modalsTogglesMap[modalID];\n    new modal_Modal(modalID, toggles);\n  });\n};\n// CONCATENATED MODULE: ./src/scripts/forms.js\nconst SELECTOR_INPUT_WRAPPER = '.form-field';\nconst SELECTOR_INPUT = '.form-field__input';\nconst SELECTOR_ERROR = '.form-field__error';\nconst CLASS_LABEL_ABOVE = 'form-field__label--above';\nconst CLASS_INVALID = 'form-field--invalid';\nconst ID_ERROR_ALERT = 'loginFormErorr';\n\nfunction handleInputEvent(event) {\n  const target = event.target;\n  changeFloatLabelState(target);\n}\n\nfunction changeFloatLabelState(input) {\n  const label = input.labels ? input.labels[0] : null;\n\n  if (label) {\n    const isLabelAbove = input.value || input === document.activeElement;\n    isLabelAbove ? label.classList.add(CLASS_LABEL_ABOVE) : label.classList.remove(CLASS_LABEL_ABOVE);\n  }\n}\n\nfunction validateRequiredInput(input) {\n  if (!input.value) {\n    setInvalidState(input);\n    return false;\n  }\n\n  return true;\n}\n\nfunction setInvalidState(input) {\n  const wrapper = input.closest(SELECTOR_INPUT_WRAPPER);\n  const error = wrapper.querySelectorAll(SELECTOR_ERROR)[0];\n  wrapper.classList.add(CLASS_INVALID);\n  error.removeAttribute('hidden');\n  input.setAttribute('aria-describedby', error.id);\n  input.setAttribute('aria-invalid', true);\n}\n\nfunction resetInvalidState(input) {\n  const wrapper = input.closest(SELECTOR_INPUT_WRAPPER);\n  const error = wrapper.querySelectorAll(SELECTOR_ERROR)[0];\n  wrapper.classList.remove(CLASS_INVALID);\n  error.setAttribute('hidden', 'hidden');\n  input.removeAttribute('aria-describedby');\n  input.removeAttribute('aria-invalid');\n}\n\nfunction initInputs() {\n  const inputs = document.querySelectorAll(SELECTOR_INPUT);\n  [...inputs].forEach(input => {\n    input.addEventListener('change', handleInputEvent);\n    input.addEventListener('focus', handleInputEvent);\n    input.addEventListener('blur', handleInputEvent);\n  });\n}\n\nfunction initLoginForm() {\n  const loginModal = document.getElementById('loginModal');\n  const loginForm = document.getElementById('loginForm');\n  const inputs = loginForm.querySelectorAll(SELECTOR_INPUT);\n\n  function addEventListeners() {\n    loginModal.addEventListener('modal.close', e => resetFormInvalidState());\n    loginForm.addEventListener('submit', submitForm);\n    [...inputs].forEach(input => {\n      input.addEventListener('keyup', e => {\n        e.target.value && resetInvalidState(e.target);\n      });\n    });\n  }\n\n  function submitForm(event) {\n    removeErrorAlert();\n    const isFormValid = validateForm();\n\n    if (isFormValid) {\n      loginModal.querySelector('[data-close-modal]').click();\n    } else {\n      event.preventDefault();\n      const invalidFields = loginForm.querySelectorAll('[aria-invalid]');\n      createErrorAlert(invalidFields.length); // invalidFields[0].focus();\n    }\n  }\n\n  function validateForm() {\n    let isFormValid = true;\n    [...inputs].forEach(input => {\n      const isValid = validateRequiredInput(input);\n      !isValid && (isFormValid = false);\n    });\n    return isFormValid;\n  }\n\n  function createErrorAlert(numOfInvalidFields) {\n    if (!document.getElementById(ID_ERROR_ALERT)) {\n      const alert = document.createElement('div');\n      alert.setAttribute('id', ID_ERROR_ALERT);\n      alert.setAttribute('role', 'alert');\n      alert.setAttribute('tabIndex', '-1');\n      alert.classList.add('visually-hidden');\n      alert.innerHTML = `Форма не была отправлена. Найдено ${numOfInvalidFields} ошибок.`;\n      loginForm.appendChild(alert);\n    }\n  }\n\n  function removeErrorAlert() {\n    const alert = document.getElementById(ID_ERROR_ALERT);\n\n    if (alert) {\n      alert.remove();\n    }\n  }\n\n  function resetFormInvalidState() {\n    [...inputs].forEach(input => {\n      resetInvalidState(input);\n    });\n    removeErrorAlert();\n  }\n\n  addEventListeners();\n}\n\nconst initForms = () => {\n  initInputs();\n  initLoginForm();\n};\n// CONCATENATED MODULE: ./src/scripts/app.js\n\n\n\n\nclass app_App {\n  constructor() {}\n\n  init() {\n    initModals();\n    initTabs();\n    initForms();\n  }\n\n}\n\nconst app = new app_App();\ndocument.addEventListener('DOMContentLoaded', () => app.init());\n// CONCATENATED MODULE: ./src/index.js\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL2luZGV4LnNjc3M/NDgwMSIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy91dGlscy9rZXlzLmpzPzA1OWQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvdGFicy5qcz9jYzAzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YWJiYWJsZS9kaXN0L2luZGV4LmVzbS5qcz82MmY3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mb2N1cy10cmFwL2Rpc3QvZm9jdXMtdHJhcC5lc20uanM/ZTE2YyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9tb2RhbC5qcz9hMGVhIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2Zvcm1zLmpzP2IzOTAiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvYXBwLmpzP2NlNGQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwibmFtZXMiOlsiS0VZX0NPREUiLCJUQUIiLCJFU0MiLCJFTkQiLCJIT01FIiwiTEVGVCIsIlVQIiwiUklHSFQiLCJET1dOIiwiU0VMRUNUT1JfVEFCIiwiU0VMRUNUT1JfVEFCU19DT05UQUlORVIiLCJTRUxFQ1RPUl9UQUJfUEFORUwiLCJTRUxFQ1RPUl9UQUJfTElTVCIsIkNMQVNTX1RBQl9BQ1RJVkUiLCJUYWJzIiwidGFiQ29udGFpbmVyIiwidGFibGlzdCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJ0YWJzIiwicGFuZWxzIiwiaXNWZXJ0aWNhbE9yaWVudGF0aW9uIiwiZ2V0QXR0cmlidXRlIiwiaSIsImxlbmd0aCIsImFkZExpc3RlbmVycyIsImluZGV4IiwiYWRkRXZlbnRMaXN0ZW5lciIsImNsaWNrRXZlbnRMaXN0ZW5lciIsImtleWRvd25FdmVudExpc3RlbmVyIiwia2V5dXBFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJ0YWIiLCJ0YXJnZXQiLCJhY3RpdmF0ZVRhYiIsImtleUNvZGUiLCJwcmV2ZW50RGVmYXVsdCIsImRldGVybWluZU9yaWVudGF0aW9uIiwia2V5Iiwic3dpdGNoVGFiT25BcnJvd1ByZXNzIiwicHJlc3NlZCIsIngiLCJmb2N1c0V2ZW50SGFuZGxlciIsImRpcmVjdGlvbiIsInVuZGVmaW5lZCIsIm5ld0luZGV4IiwiYWN0aXZlSW5kZXgiLCJmb2N1cyIsInNldEZvY3VzIiwiZGVhY3RpdmF0ZVRhYnMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJjbGFzc0xpc3QiLCJhZGQiLCJwYW5lbElkIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImZvckVhY2giLCJyZW1vdmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicGFuZWwiLCJpbml0VGFicyIsInRhYkNvbmF0aW5lciIsIkJPRFlfT1BFTl9DTEFTUyIsIk1PREFMX09QRU5fQ0xBU1MiLCJEQVRBX01PREFMX1RPR0dMRSIsIkRBVEFfTU9EQUxfQ0xPU0UiLCJFVkVOVF9DTE9TRSIsIkVWRU5UX09QRU4iLCJhY3RpdmVNb2RhbCIsIk1vZGFsIiwiY29uc3RydWN0b3IiLCJtb2RhbElEIiwidG9nZ2xlcyIsIm1vZGFsIiwiZm9jdXNUcmFwIiwiY3JlYXRlRm9jdXNUcmFwIiwiaW5pdFRvZ2dsZXMiLCJldmVudENsb3NlIiwiRXZlbnQiLCJldmVudE9wZW4iLCJmaWx0ZXIiLCJCb29sZWFuIiwidG9nZ2xlIiwic2hvd01vZGFsIiwiYWN0aXZlRWxlbWVudCIsImJvZHkiLCJhY3RpdmF0ZSIsImFkZEV2ZW50TGlzdGVuZXJzIiwiZGlzcGF0Y2hFdmVudCIsImNsb3NlTW9kYWwiLCJyZW1vdmVFdmVudExpc3RlbmVycyIsImRlYWN0aXZhdGUiLCJoYW5kbGVNb2RhbENsaWNrIiwiaGFuZGxlRG9jdW1lbnRLZXlVcEV2ZW50Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2xvc2VBdHRyIiwiaGFzQXR0cmlidXRlIiwiY2xvc2VzdCIsImhpZGVBbGxDb250ZW50Rm9yU2NyZWVuUmVhZGVycyIsImNoaWxkcmVuIiwiY2hpbGQiLCJzaG93QWxsQ29udGVudEZvclNjcmVlblJlYWRlcnMiLCJnZW5lcmF0ZU1vZGFsc1RvZ2dsZXNNYXAiLCJtYXAiLCJwdXNoIiwiaW5pdE1vZGFscyIsIm1vZGFsc1RvZ2dsZXNNYXAiLCJPYmplY3QiLCJrZXlzIiwiU0VMRUNUT1JfSU5QVVRfV1JBUFBFUiIsIlNFTEVDVE9SX0lOUFVUIiwiU0VMRUNUT1JfRVJST1IiLCJDTEFTU19MQUJFTF9BQk9WRSIsIkNMQVNTX0lOVkFMSUQiLCJJRF9FUlJPUl9BTEVSVCIsImhhbmRsZUlucHV0RXZlbnQiLCJjaGFuZ2VGbG9hdExhYmVsU3RhdGUiLCJpbnB1dCIsImxhYmVsIiwibGFiZWxzIiwiaXNMYWJlbEFib3ZlIiwidmFsdWUiLCJ2YWxpZGF0ZVJlcXVpcmVkSW5wdXQiLCJzZXRJbnZhbGlkU3RhdGUiLCJ3cmFwcGVyIiwiZXJyb3IiLCJpZCIsInJlc2V0SW52YWxpZFN0YXRlIiwiaW5pdElucHV0cyIsImlucHV0cyIsImluaXRMb2dpbkZvcm0iLCJsb2dpbk1vZGFsIiwibG9naW5Gb3JtIiwiZSIsInJlc2V0Rm9ybUludmFsaWRTdGF0ZSIsInN1Ym1pdEZvcm0iLCJyZW1vdmVFcnJvckFsZXJ0IiwiaXNGb3JtVmFsaWQiLCJ2YWxpZGF0ZUZvcm0iLCJxdWVyeVNlbGVjdG9yIiwiY2xpY2siLCJpbnZhbGlkRmllbGRzIiwiY3JlYXRlRXJyb3JBbGVydCIsImlzVmFsaWQiLCJudW1PZkludmFsaWRGaWVsZHMiLCJhbGVydCIsImNyZWF0ZUVsZW1lbnQiLCJpbm5lckhUTUwiLCJhcHBlbmRDaGlsZCIsImluaXRGb3JtcyIsIkFwcCIsImluaXQiLCJhcHAiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0FDQU8sTUFBTUEsUUFBUSxHQUFHO0FBQ3BCQyxLQUFHLEVBQUUsQ0FEZTtBQUVwQkMsS0FBRyxFQUFFLEVBRmU7QUFHcEJDLEtBQUcsRUFBRSxFQUhlO0FBSXBCQyxNQUFJLEVBQUUsRUFKYztBQUtwQkMsTUFBSSxFQUFFLEVBTGM7QUFNcEJDLElBQUUsRUFBRSxFQU5nQjtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5Qix3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSx3REFBd0QsV0FBVztBQUNuRSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSxHQUFH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QW1CLFVBQTFFO0FBQ0FaLGVBQVMsQ0FBQ2dCLFdBQVYsQ0FBc0JILEtBQXRCO0FBQ0g7QUFDSjs7QUFFRCxXQUFTVCxnQkFBVCxHQUE0QjtBQUN4QixVQUFNUyxLQUFLLEdBQUczRixRQUFRLENBQUNDLGNBQVQsQ0FBd0IyRCxjQUF4QixDQUFkOztBQUNBLFFBQUkrQixLQUFKLEVBQVc7QUFDUEEsV0FBSyxDQUFDeEYsTUFBTjtBQUNIO0FBQ0o7O0FBRUQsV0FBUzZFLHFCQUFULEdBQWlDO0FBQzdCLEtBQUMsR0FBR0wsTUFBSixFQUFZekUsT0FBWixDQUFxQjZELEtBQUQsSUFBVztBQUMzQlUsdUJBQWlCLENBQUNWLEtBQUQsQ0FBakI7QUFDSCxLQUZEO0FBR0FtQixvQkFBZ0I7QUFDbkI7O0FBRURqRCxtQkFBaUI7QUFDcEI7O0FBRU0sTUFBTThELFNBQVMsR0FBRyxNQUFNO0FBQzNCckIsWUFBVTtBQUNWRSxlQUFhO0FBQ2hCLENBSE0sQzs7QUM3SFA7QUFDQTtBQUNBOztBQUVBLE1BQU1vQixPQUFOLENBQVU7QUFDTmhGLGFBQVcsR0FBRyxDQUFFOztBQUNoQmlGLE1BQUksR0FBRztBQUNIOUMsY0FBVTtBQUNWN0MsWUFBUTtBQUNSeUYsYUFBUztBQUNaOztBQU5LOztBQVNWLE1BQU1HLEdBQUcsR0FBRyxJQUFJRixPQUFKLEVBQVo7QUFDQWhHLFFBQVEsQ0FBQzVCLGdCQUFULENBQTBCLGtCQUExQixFQUE4QyxNQUFNOEgsR0FBRyxDQUFDRCxJQUFKLEVBQXBELEU7O0FDZEEiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsImV4cG9ydCBjb25zdCBLRVlfQ09ERSA9IHtcbiAgICBUQUI6IDksXG4gICAgRVNDOiAyNyxcbiAgICBFTkQ6IDM1LFxuICAgIEhPTUU6IDM2LFxuICAgIExFRlQ6IDM3LFxuICAgIFVQOiAzOCxcbiAgICBSSUdIVDogMzksXG4gICAgRE9XTjogNDAsXG59O1xuIiwiaW1wb3J0IHsgS0VZX0NPREUgfSBmcm9tICcuL3V0aWxzL2tleXMnO1xuXG5jb25zdCBTRUxFQ1RPUl9UQUIgPSAnW3JvbGU9XCJ0YWJcIl0nO1xuY29uc3QgU0VMRUNUT1JfVEFCU19DT05UQUlORVIgPSAnLnRhYnMnO1xuY29uc3QgU0VMRUNUT1JfVEFCX1BBTkVMID0gJ1tyb2xlPVwidGFicGFuZWxcIl0nO1xuY29uc3QgU0VMRUNUT1JfVEFCX0xJU1QgPSAnW3JvbGU9XCJ0YWJsaXN0XCJdJztcbmNvbnN0IENMQVNTX1RBQl9BQ1RJVkUgPSAnYWN0aXZlJztcblxuY29uc3QgVGFicyA9ICh0YWJDb250YWluZXIpID0+IHtcbiAgICBsZXQgdGFibGlzdCA9IHRhYkNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX1RBQl9MSVNUKVswXTtcbiAgICBsZXQgdGFicyA9IHRhYkNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX1RBQik7XG4gICAgbGV0IHBhbmVscyA9IHRhYkNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX1RBQl9QQU5FTCk7XG4gICAgbGV0IGlzVmVydGljYWxPcmllbnRhdGlvbiA9IHRhYmxpc3QuZ2V0QXR0cmlidXRlKCdhcmlhLW9yaWVudGF0aW9uJykgPT09ICd2ZXJ0aWNhbCc7XG5cbiAgICAvLyBCaW5kIGxpc3RlbmVyc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFicy5sZW5ndGg7ICsraSkge1xuICAgICAgICBhZGRMaXN0ZW5lcnMoaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGluZGV4KSB7XG4gICAgICAgIHRhYnNbaW5kZXhdLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xpY2tFdmVudExpc3RlbmVyKTtcbiAgICAgICAgdGFic1tpbmRleF0uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleWRvd25FdmVudExpc3RlbmVyKTtcbiAgICAgICAgdGFic1tpbmRleF0uYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBrZXl1cEV2ZW50TGlzdGVuZXIpO1xuICAgICAgICB0YWJzW2luZGV4XS5pbmRleCA9IGluZGV4O1xuICAgIH1cblxuICAgIC8vIFdoZW4gYSB0YWIgaXMgY2xpY2tlZCwgYWN0aXZhdGVUYWIgaXMgZmlyZWQgdG8gYWN0aXZhdGUgaXRcbiAgICBmdW5jdGlvbiBjbGlja0V2ZW50TGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgbGV0IHRhYiA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgYWN0aXZhdGVUYWIodGFiLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGtleWRvd24gb24gdGFic1xuICAgIGZ1bmN0aW9uIGtleWRvd25FdmVudExpc3RlbmVyKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBLRVlfQ09ERS5FTkQ6XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0ZVRhYih0YWJzW3RhYnMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLRVlfQ09ERS5IT01FOlxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGVUYWIodGFic1swXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIFVwIGFuZCBkb3duIGFyZSBpbiBrZXlkb3duXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gcHJldmVudCBwYWdlIHNjcm9sbCA+OilcbiAgICAgICAgICAgIGNhc2UgS0VZX0NPREUuVVA6XG4gICAgICAgICAgICBjYXNlIEtFWV9DT0RFLkRPV046XG4gICAgICAgICAgICAgICAgZGV0ZXJtaW5lT3JpZW50YXRpb24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGtleXVwIG9uIHRhYnNcbiAgICBmdW5jdGlvbiBrZXl1cEV2ZW50TGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIEtFWV9DT0RFLkxFRlQ6XG4gICAgICAgICAgICBjYXNlIEtFWV9DT0RFLlJJR0hUOlxuICAgICAgICAgICAgICAgIGRldGVybWluZU9yaWVudGF0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdoZW4gYSB0YWJsaXN0w6LigqzihKJzIGFyaWEtb3JpZW50YXRpb24gaXMgc2V0IHRvIHZlcnRpY2FsLFxuICAgIC8vIG9ubHkgdXAgYW5kIGRvd24gYXJyb3cgc2hvdWxkIGZ1bmN0aW9uLlxuICAgIC8vIEluIGFsbCBvdGhlciBjYXNlcyBvbmx5IGxlZnQgYW5kIHJpZ2h0IGFycm93IGZ1bmN0aW9uLlxuICAgIGZ1bmN0aW9uIGRldGVybWluZU9yaWVudGF0aW9uKGV2ZW50KSB7XG4gICAgICAgIGxldCBrZXkgPSBldmVudC5rZXlDb2RlO1xuXG4gICAgICAgIGlmIChpc1ZlcnRpY2FsT3JpZW50YXRpb24gJiYgKGtleSA9PT0gS0VZX0NPREUuVVAgfHwga2V5ID09PSBLRVlfQ09ERS5ET1dOKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHN3aXRjaFRhYk9uQXJyb3dQcmVzcyhldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzVmVydGljYWxPcmllbnRhdGlvbiAmJiAoa2V5ID09PSBLRVlfQ09ERS5MRUZUIHx8IGtleSA9PT0gS0VZX0NPREUuUklHSFQpKSB7XG4gICAgICAgICAgICBzd2l0Y2hUYWJPbkFycm93UHJlc3MoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRWl0aGVyIGZvY3VzIHRoZSBuZXh0LCBwcmV2aW91cywgZmlyc3QsIG9yIGxhc3QgdGFiXG4gICAgLy8gZGVwZW5pbmcgb24ga2V5IHByZXNzZWRcbiAgICBmdW5jdGlvbiBzd2l0Y2hUYWJPbkFycm93UHJlc3MoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgcHJlc3NlZCA9IGV2ZW50LmtleUNvZGU7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRhYnMubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIHRhYnNbeF0uYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmb2N1c0V2ZW50SGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPVxuICAgICAgICAgICAgcHJlc3NlZCA9PT0gS0VZX0NPREUuVVAgfHwgcHJlc3NlZCA9PT0gS0VZX0NPREUuTEVGVFxuICAgICAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgICAgICA6IHByZXNzZWQgPT09IEtFWV9DT0RFLkRPV04gfHwgcHJlc3NlZCA9PT0gS0VZX0NPREUuUklHSFRcbiAgICAgICAgICAgICAgICA/IDFcbiAgICAgICAgICAgICAgICA6IDA7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiAhPT0gMCAmJiB0YXJnZXQuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0YXJnZXQuaW5kZXggKyBkaXJlY3Rpb247XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVJbmRleCA9IG5ld0luZGV4IDwgMCA/IHRhYnMubGVuZ3RoIC0gMSA6IG5ld0luZGV4IDwgdGFicy5sZW5ndGggPyBuZXdJbmRleCA6IDA7XG4gICAgICAgICAgICB0YWJzW2FjdGl2ZUluZGV4XS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWN0aXZhdGVzIGFueSBnaXZlbiB0YWIgcGFuZWxcbiAgICBmdW5jdGlvbiBhY3RpdmF0ZVRhYih0YWIsIHNldEZvY3VzKSB7XG4gICAgICAgIHNldEZvY3VzID0gc2V0Rm9jdXMgfHwgdHJ1ZTtcbiAgICAgICAgLy8gRGVhY3RpdmF0ZSBhbGwgb3RoZXIgdGFic1xuICAgICAgICBkZWFjdGl2YXRlVGFicygpO1xuXG4gICAgICAgIHRhYi5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgIHRhYi5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICAgICAgICB0YWIuY2xhc3NMaXN0LmFkZChDTEFTU19UQUJfQUNUSVZFKTtcblxuICAgICAgICBjb25zdCBwYW5lbElkID0gdGFiLmdldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwYW5lbElkKS5yZW1vdmVBdHRyaWJ1dGUoJ2hpZGRlbicpO1xuXG4gICAgICAgIC8vIFNldCBmb2N1cyB3aGVuIHJlcXVpcmVkXG4gICAgICAgIGlmIChzZXRGb2N1cykge1xuICAgICAgICAgICAgdGFiLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWFjdGl2YXRlIGFsbCB0YWJzIGFuZCB0YWIgcGFuZWxzXG4gICAgZnVuY3Rpb24gZGVhY3RpdmF0ZVRhYnMoKSB7XG4gICAgICAgIFsuLi50YWJzXS5mb3JFYWNoKCh0YWIpID0+IHtcbiAgICAgICAgICAgIHRhYi5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgICAgICB0YWIuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICB0YWIuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19UQUJfQUNUSVZFKTtcbiAgICAgICAgICAgIHRhYi5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIGZvY3VzRXZlbnRIYW5kbGVyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgWy4uLnBhbmVsc10uZm9yRWFjaCgocGFuZWwpID0+IHtcbiAgICAgICAgICAgIHBhbmVsLnNldEF0dHJpYnV0ZSgnaGlkZGVuJywgJ2hpZGRlbicpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb2N1c0V2ZW50SGFuZGxlcihldmVudCkge1xuICAgICAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBhY3RpdmF0ZVRhYih0YXJnZXQsIGZhbHNlKTtcbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgaW5pdFRhYnMgPSAoKSA9PiB7XG4gICAgY29uc3QgdGFicyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfVEFCU19DT05UQUlORVIpO1xuICAgIFsuLi50YWJzXS5mb3JFYWNoKCh0YWJDb25hdGluZXIpID0+IHtcbiAgICAgICAgVGFicyh0YWJDb25hdGluZXIpO1xuICAgIH0pO1xufTtcbiIsIi8qIVxuKiB0YWJiYWJsZSA1LjEuMlxuKiBAbGljZW5zZSBNSVQsIGh0dHBzOi8vZ2l0aHViLmNvbS9mb2N1cy10cmFwL3RhYmJhYmxlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiovXG52YXIgY2FuZGlkYXRlU2VsZWN0b3JzID0gWydpbnB1dCcsICdzZWxlY3QnLCAndGV4dGFyZWEnLCAnYVtocmVmXScsICdidXR0b24nLCAnW3RhYmluZGV4XScsICdhdWRpb1tjb250cm9sc10nLCAndmlkZW9bY29udHJvbHNdJywgJ1tjb250ZW50ZWRpdGFibGVdOm5vdChbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0pJywgJ2RldGFpbHM+c3VtbWFyeSddO1xudmFyIGNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovY2FuZGlkYXRlU2VsZWN0b3JzLmpvaW4oJywnKTtcbnZhciBtYXRjaGVzID0gdHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnID8gZnVuY3Rpb24gKCkge30gOiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcblxuZnVuY3Rpb24gdGFiYmFibGUoZWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciByZWd1bGFyVGFiYmFibGVzID0gW107XG4gIHZhciBvcmRlcmVkVGFiYmFibGVzID0gW107XG4gIHZhciBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhlbCwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUpO1xuICBjYW5kaWRhdGVzLmZvckVhY2goZnVuY3Rpb24gKGNhbmRpZGF0ZSwgaSkge1xuICAgIHZhciBjYW5kaWRhdGVUYWJpbmRleCA9IGdldFRhYmluZGV4KGNhbmRpZGF0ZSk7XG5cbiAgICBpZiAoY2FuZGlkYXRlVGFiaW5kZXggPT09IDApIHtcbiAgICAgIHJlZ3VsYXJUYWJiYWJsZXMucHVzaChjYW5kaWRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmRlcmVkVGFiYmFibGVzLnB1c2goe1xuICAgICAgICBkb2N1bWVudE9yZGVyOiBpLFxuICAgICAgICB0YWJJbmRleDogY2FuZGlkYXRlVGFiaW5kZXgsXG4gICAgICAgIG5vZGU6IGNhbmRpZGF0ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHRhYmJhYmxlTm9kZXMgPSBvcmRlcmVkVGFiYmFibGVzLnNvcnQoc29ydE9yZGVyZWRUYWJiYWJsZXMpLm1hcChmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhLm5vZGU7XG4gIH0pLmNvbmNhdChyZWd1bGFyVGFiYmFibGVzKTtcbiAgcmV0dXJuIHRhYmJhYmxlTm9kZXM7XG59XG5cbmZ1bmN0aW9uIGZvY3VzYWJsZShlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKGVsLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUpO1xuICByZXR1cm4gY2FuZGlkYXRlcztcbn1cblxuZnVuY3Rpb24gZ2V0Q2FuZGlkYXRlcyhlbCwgaW5jbHVkZUNvbnRhaW5lciwgZmlsdGVyKSB7XG4gIHZhciBjYW5kaWRhdGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGVsLnF1ZXJ5U2VsZWN0b3JBbGwoY2FuZGlkYXRlU2VsZWN0b3IpKTtcblxuICBpZiAoaW5jbHVkZUNvbnRhaW5lciAmJiBtYXRjaGVzLmNhbGwoZWwsIGNhbmRpZGF0ZVNlbGVjdG9yKSkge1xuICAgIGNhbmRpZGF0ZXMudW5zaGlmdChlbCk7XG4gIH1cblxuICBjYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5maWx0ZXIoZmlsdGVyKTtcbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShub2RlKSB7XG4gIGlmICghaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShub2RlKSB8fCBpc05vblRhYmJhYmxlUmFkaW8obm9kZSkgfHwgZ2V0VGFiaW5kZXgobm9kZSkgPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzVGFiYmFibGUobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuXG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgY2FuZGlkYXRlU2VsZWN0b3IpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUobm9kZSkge1xuICBpZiAobm9kZS5kaXNhYmxlZCB8fCBpc0hpZGRlbklucHV0KG5vZGUpIHx8IGlzSGlkZGVuKG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqL2NhbmRpZGF0ZVNlbGVjdG9ycy5jb25jYXQoJ2lmcmFtZScpLmpvaW4oJywnKTtcblxuZnVuY3Rpb24gaXNGb2N1c2FibGUobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuXG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBnZXRUYWJpbmRleChub2RlKSB7XG4gIHZhciB0YWJpbmRleEF0dHIgPSBwYXJzZUludChub2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApO1xuXG4gIGlmICghaXNOYU4odGFiaW5kZXhBdHRyKSkge1xuICAgIHJldHVybiB0YWJpbmRleEF0dHI7XG4gIH0gLy8gQnJvd3NlcnMgZG8gbm90IHJldHVybiBgdGFiSW5kZXhgIGNvcnJlY3RseSBmb3IgY29udGVudEVkaXRhYmxlIG5vZGVzO1xuICAvLyBzbyBpZiB0aGV5IGRvbid0IGhhdmUgYSB0YWJpbmRleCBhdHRyaWJ1dGUgc3BlY2lmaWNhbGx5IHNldCwgYXNzdW1lIGl0J3MgMC5cblxuXG4gIGlmIChpc0NvbnRlbnRFZGl0YWJsZShub2RlKSkge1xuICAgIHJldHVybiAwO1xuICB9IC8vIGluIENocm9tZSwgPGF1ZGlvIGNvbnRyb2xzLz4gYW5kIDx2aWRlbyBjb250cm9scy8+IGVsZW1lbnRzIGdldCBhIGRlZmF1bHRcbiAgLy8gIGB0YWJJbmRleGAgb2YgLTEgd2hlbiB0aGUgJ3RhYmluZGV4JyBhdHRyaWJ1dGUgaXNuJ3Qgc3BlY2lmaWVkIGluIHRoZSBET00sXG4gIC8vICB5ZXQgdGhleSBhcmUgc3RpbGwgcGFydCBvZiB0aGUgcmVndWxhciB0YWIgb3JkZXI7IGluIEZGLCB0aGV5IGdldCBhIGRlZmF1bHRcbiAgLy8gIGB0YWJJbmRleGAgb2YgMDsgc2luY2UgQ2hyb21lIHN0aWxsIHB1dHMgdGhvc2UgZWxlbWVudHMgaW4gdGhlIHJlZ3VsYXIgdGFiXG4gIC8vICBvcmRlciwgY29uc2lkZXIgdGhlaXIgdGFiIGluZGV4IHRvIGJlIDBcblxuXG4gIGlmICgobm9kZS5ub2RlTmFtZSA9PT0gJ0FVRElPJyB8fCBub2RlLm5vZGVOYW1lID09PSAnVklERU8nKSAmJiBub2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIG5vZGUudGFiSW5kZXg7XG59XG5cbmZ1bmN0aW9uIHNvcnRPcmRlcmVkVGFiYmFibGVzKGEsIGIpIHtcbiAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXggPyBhLmRvY3VtZW50T3JkZXIgLSBiLmRvY3VtZW50T3JkZXIgOiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDtcbn1cblxuZnVuY3Rpb24gaXNDb250ZW50RWRpdGFibGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJztcbn1cblxuZnVuY3Rpb24gaXNJbnB1dChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUgPT09ICdJTlBVVCc7XG59XG5cbmZ1bmN0aW9uIGlzSGlkZGVuSW5wdXQobm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdoaWRkZW4nO1xufVxuXG5mdW5jdGlvbiBpc1JhZGlvKG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAncmFkaW8nO1xufVxuXG5mdW5jdGlvbiBpc05vblRhYmJhYmxlUmFkaW8obm9kZSkge1xuICByZXR1cm4gaXNSYWRpbyhub2RlKSAmJiAhaXNUYWJiYWJsZVJhZGlvKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBnZXRDaGVja2VkUmFkaW8obm9kZXMsIGZvcm0pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXS5jaGVja2VkICYmIG5vZGVzW2ldLmZvcm0gPT09IGZvcm0pIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNUYWJiYWJsZVJhZGlvKG5vZGUpIHtcbiAgaWYgKCFub2RlLm5hbWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciByYWRpb1Njb3BlID0gbm9kZS5mb3JtIHx8IG5vZGUub3duZXJEb2N1bWVudDtcbiAgdmFyIHJhZGlvU2V0ID0gcmFkaW9TY29wZS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIicgKyBub2RlLm5hbWUgKyAnXCJdJyk7XG4gIHZhciBjaGVja2VkID0gZ2V0Q2hlY2tlZFJhZGlvKHJhZGlvU2V0LCBub2RlLmZvcm0pO1xuICByZXR1cm4gIWNoZWNrZWQgfHwgY2hlY2tlZCA9PT0gbm9kZTtcbn1cblxuZnVuY3Rpb24gaXNIaWRkZW4obm9kZSkge1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS52aXNpYmlsaXR5ID09PSAnaGlkZGVuJykgcmV0dXJuIHRydWU7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5kaXNwbGF5ID09PSAnbm9uZScpIHJldHVybiB0cnVlO1xuICAgIG5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCB7IGZvY3VzYWJsZSwgaXNGb2N1c2FibGUsIGlzVGFiYmFibGUsIHRhYmJhYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iLCIvKiFcbiogZm9jdXMtdHJhcCA2LjEuM1xuKiBAbGljZW5zZSBNSVQsIGh0dHBzOi8vZ2l0aHViLmNvbS9mb2N1cy10cmFwL2ZvY3VzLXRyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRVxuKi9cbmltcG9ydCB7IGlzRm9jdXNhYmxlLCB0YWJiYWJsZSB9IGZyb20gJ3RhYmJhYmxlJztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KTtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBhY3RpdmVGb2N1c0RlbGF5O1xuXG52YXIgYWN0aXZlRm9jdXNUcmFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRyYXBRdWV1ZSA9IFtdO1xuICByZXR1cm4ge1xuICAgIGFjdGl2YXRlVHJhcDogZnVuY3Rpb24gYWN0aXZhdGVUcmFwKHRyYXApIHtcbiAgICAgIGlmICh0cmFwUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgYWN0aXZlVHJhcCA9IHRyYXBRdWV1ZVt0cmFwUXVldWUubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGFjdGl2ZVRyYXAgIT09IHRyYXApIHtcbiAgICAgICAgICBhY3RpdmVUcmFwLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRyYXBJbmRleCA9IHRyYXBRdWV1ZS5pbmRleE9mKHRyYXApO1xuXG4gICAgICBpZiAodHJhcEluZGV4ID09PSAtMSkge1xuICAgICAgICB0cmFwUXVldWUucHVzaCh0cmFwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vdmUgdGhpcyBleGlzdGluZyB0cmFwIHRvIHRoZSBmcm9udCBvZiB0aGUgcXVldWVcbiAgICAgICAgdHJhcFF1ZXVlLnNwbGljZSh0cmFwSW5kZXgsIDEpO1xuICAgICAgICB0cmFwUXVldWUucHVzaCh0cmFwKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlYWN0aXZhdGVUcmFwOiBmdW5jdGlvbiBkZWFjdGl2YXRlVHJhcCh0cmFwKSB7XG4gICAgICB2YXIgdHJhcEluZGV4ID0gdHJhcFF1ZXVlLmluZGV4T2YodHJhcCk7XG5cbiAgICAgIGlmICh0cmFwSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRyYXBRdWV1ZS5zcGxpY2UodHJhcEluZGV4LCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYXBRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRyYXBRdWV1ZVt0cmFwUXVldWUubGVuZ3RoIC0gMV0udW5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0oKTtcblxuZnVuY3Rpb24gY3JlYXRlRm9jdXNUcmFwKGVsZW1lbnQsIHVzZXJPcHRpb25zKSB7XG4gIHZhciBkb2MgPSBkb2N1bWVudDtcbiAgdmFyIGNvbnRhaW5lciA9IHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyA/IGRvYy5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpIDogZWxlbWVudDtcblxuICB2YXIgY29uZmlnID0gX29iamVjdFNwcmVhZDIoe1xuICAgIHJldHVybkZvY3VzT25EZWFjdGl2YXRlOiB0cnVlLFxuICAgIGVzY2FwZURlYWN0aXZhdGVzOiB0cnVlLFxuICAgIGRlbGF5SW5pdGlhbEZvY3VzOiB0cnVlXG4gIH0sIHVzZXJPcHRpb25zKTtcblxuICB2YXIgc3RhdGUgPSB7XG4gICAgZmlyc3RUYWJiYWJsZU5vZGU6IG51bGwsXG4gICAgbGFzdFRhYmJhYmxlTm9kZTogbnVsbCxcbiAgICBub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb246IG51bGwsXG4gICAgbW9zdFJlY2VudGx5Rm9jdXNlZE5vZGU6IG51bGwsXG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBwYXVzZWQ6IGZhbHNlXG4gIH07XG4gIHZhciB0cmFwID0ge1xuICAgIGFjdGl2YXRlOiBhY3RpdmF0ZSxcbiAgICBkZWFjdGl2YXRlOiBkZWFjdGl2YXRlLFxuICAgIHBhdXNlOiBwYXVzZSxcbiAgICB1bnBhdXNlOiB1bnBhdXNlXG4gIH07XG4gIHJldHVybiB0cmFwO1xuXG4gIGZ1bmN0aW9uIGFjdGl2YXRlKGFjdGl2YXRlT3B0aW9ucykge1xuICAgIGlmIChzdGF0ZS5hY3RpdmUpIHJldHVybjtcbiAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgc3RhdGUuYWN0aXZlID0gdHJ1ZTtcbiAgICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgICBzdGF0ZS5ub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb24gPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICB2YXIgb25BY3RpdmF0ZSA9IGFjdGl2YXRlT3B0aW9ucyAmJiBhY3RpdmF0ZU9wdGlvbnMub25BY3RpdmF0ZSA/IGFjdGl2YXRlT3B0aW9ucy5vbkFjdGl2YXRlIDogY29uZmlnLm9uQWN0aXZhdGU7XG5cbiAgICBpZiAob25BY3RpdmF0ZSkge1xuICAgICAgb25BY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIGFkZExpc3RlbmVycygpO1xuICAgIHJldHVybiB0cmFwO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVhY3RpdmF0ZShkZWFjdGl2YXRlT3B0aW9ucykge1xuICAgIGlmICghc3RhdGUuYWN0aXZlKSByZXR1cm47XG4gICAgY2xlYXJUaW1lb3V0KGFjdGl2ZUZvY3VzRGVsYXkpO1xuICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgIHN0YXRlLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICAgIGFjdGl2ZUZvY3VzVHJhcHMuZGVhY3RpdmF0ZVRyYXAodHJhcCk7XG4gICAgdmFyIG9uRGVhY3RpdmF0ZSA9IGRlYWN0aXZhdGVPcHRpb25zICYmIGRlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZSAhPT0gdW5kZWZpbmVkID8gZGVhY3RpdmF0ZU9wdGlvbnMub25EZWFjdGl2YXRlIDogY29uZmlnLm9uRGVhY3RpdmF0ZTtcblxuICAgIGlmIChvbkRlYWN0aXZhdGUpIHtcbiAgICAgIG9uRGVhY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIHZhciByZXR1cm5Gb2N1cyA9IGRlYWN0aXZhdGVPcHRpb25zICYmIGRlYWN0aXZhdGVPcHRpb25zLnJldHVybkZvY3VzICE9PSB1bmRlZmluZWQgPyBkZWFjdGl2YXRlT3B0aW9ucy5yZXR1cm5Gb2N1cyA6IGNvbmZpZy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZTtcblxuICAgIGlmIChyZXR1cm5Gb2N1cykge1xuICAgICAgZGVsYXkoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnlGb2N1cyhnZXRSZXR1cm5Gb2N1c05vZGUoc3RhdGUubm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJhcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIGlmIChzdGF0ZS5wYXVzZWQgfHwgIXN0YXRlLmFjdGl2ZSkgcmV0dXJuO1xuICAgIHN0YXRlLnBhdXNlZCA9IHRydWU7XG4gICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gIH1cblxuICBmdW5jdGlvbiB1bnBhdXNlKCkge1xuICAgIGlmICghc3RhdGUucGF1c2VkIHx8ICFzdGF0ZS5hY3RpdmUpIHJldHVybjtcbiAgICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgYWRkTGlzdGVuZXJzKCk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKCFzdGF0ZS5hY3RpdmUpIHJldHVybjsgLy8gVGhlcmUgY2FuIGJlIG9ubHkgb25lIGxpc3RlbmluZyBmb2N1cyB0cmFwIGF0IGEgdGltZVxuXG4gICAgYWN0aXZlRm9jdXNUcmFwcy5hY3RpdmF0ZVRyYXAodHJhcCk7IC8vIERlbGF5IGVuc3VyZXMgdGhhdCB0aGUgZm9jdXNlZCBlbGVtZW50IGRvZXNuJ3QgY2FwdHVyZSB0aGUgZXZlbnRcbiAgICAvLyB0aGF0IGNhdXNlZCB0aGUgZm9jdXMgdHJhcCBhY3RpdmF0aW9uLlxuXG4gICAgYWN0aXZlRm9jdXNEZWxheSA9IGNvbmZpZy5kZWxheUluaXRpYWxGb2N1cyA/IGRlbGF5KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeUZvY3VzKGdldEluaXRpYWxGb2N1c05vZGUoKSk7XG4gICAgfSkgOiB0cnlGb2N1cyhnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgY2hlY2tGb2N1c0luLCB0cnVlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgY2hlY2tQb2ludGVyRG93biwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjaGVja1BvaW50ZXJEb3duLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjaGVja0NsaWNrLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNoZWNrS2V5LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gdHJhcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBpZiAoIXN0YXRlLmFjdGl2ZSkgcmV0dXJuO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgY2hlY2tGb2N1c0luLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjaGVja0NsaWNrLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNoZWNrS2V5LCB0cnVlKTtcbiAgICByZXR1cm4gdHJhcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5vZGVGb3JPcHRpb24ob3B0aW9uTmFtZSkge1xuICAgIHZhciBvcHRpb25WYWx1ZSA9IGNvbmZpZ1tvcHRpb25OYW1lXTtcbiAgICB2YXIgbm9kZSA9IG9wdGlvblZhbHVlO1xuXG4gICAgaWYgKCFvcHRpb25WYWx1ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5vZGUgPSBkb2MucXVlcnlTZWxlY3RvcihvcHRpb25WYWx1ZSk7XG5cbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2AnICsgb3B0aW9uTmFtZSArICdgIHJlZmVycyB0byBubyBrbm93biBub2RlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbm9kZSA9IG9wdGlvblZhbHVlKCk7XG5cbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2AnICsgb3B0aW9uTmFtZSArICdgIGRpZCBub3QgcmV0dXJuIGEgbm9kZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW5pdGlhbEZvY3VzTm9kZSgpIHtcbiAgICB2YXIgbm9kZTtcblxuICAgIGlmIChnZXROb2RlRm9yT3B0aW9uKCdpbml0aWFsRm9jdXMnKSAhPT0gbnVsbCkge1xuICAgICAgbm9kZSA9IGdldE5vZGVGb3JPcHRpb24oJ2luaXRpYWxGb2N1cycpO1xuICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLmNvbnRhaW5zKGRvYy5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgbm9kZSA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gc3RhdGUuZmlyc3RUYWJiYWJsZU5vZGUgfHwgZ2V0Tm9kZUZvck9wdGlvbignZmFsbGJhY2tGb2N1cycpO1xuICAgIH1cblxuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIGZvY3VzLXRyYXAgbmVlZHMgdG8gaGF2ZSBhdCBsZWFzdCBvbmUgZm9jdXNhYmxlIGVsZW1lbnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJldHVybkZvY3VzTm9kZShwcmV2aW91c0FjdGl2ZUVsZW1lbnQpIHtcbiAgICB2YXIgbm9kZSA9IGdldE5vZGVGb3JPcHRpb24oJ3NldFJldHVybkZvY3VzJyk7XG4gICAgcmV0dXJuIG5vZGUgPyBub2RlIDogcHJldmlvdXNBY3RpdmVFbGVtZW50O1xuICB9IC8vIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSBvbiBtb3VzZWRvd24gYW5kIHRvdWNoc3RhcnQgaW5zdGVhZCBvZiBjbGlja1xuICAvLyBzbyB0aGF0IGl0IHByZWNlZGVzIHRoZSBmb2N1cyBldmVudC5cblxuXG4gIGZ1bmN0aW9uIGNoZWNrUG9pbnRlckRvd24oZSkge1xuICAgIGlmIChjb250YWluZXIuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAvLyBhbGxvdyB0aGUgY2xpY2sgc2luY2UgaXQgb2N1cnJlZCBpbnNpZGUgdGhlIHRyYXBcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzKSB7XG4gICAgICAvLyBpbW1lZGlhdGVseSBkZWFjdGl2YXRlIHRoZSB0cmFwXG4gICAgICBkZWFjdGl2YXRlKHtcbiAgICAgICAgLy8gaWYsIG9uIGRlYWN0aXZhdGlvbiwgd2Ugc2hvdWxkIHJldHVybiBmb2N1cyB0byB0aGUgbm9kZSBvcmlnaW5hbGx5LWZvY3VzZWRcbiAgICAgICAgLy8gIHdoZW4gdGhlIHRyYXAgd2FzIGFjdGl2YXRlZCAob3IgdGhlIGNvbmZpZ3VyZWQgYHNldFJldHVybkZvY3VzYCBub2RlKSxcbiAgICAgICAgLy8gIHRoZW4gYXNzdW1lIGl0J3MgYWxzbyBPSyB0byByZXR1cm4gZm9jdXMgdG8gdGhlIG91dHNpZGUgbm9kZSB0aGF0IHdhc1xuICAgICAgICAvLyAganVzdCBjbGlja2VkLCBjYXVzaW5nIGRlYWN0aXZhdGlvbiwgYXMgbG9uZyBhcyB0aGF0IG5vZGUgaXMgZm9jdXNhYmxlO1xuICAgICAgICAvLyAgaWYgaXQgaXNuJ3QgZm9jdXNhYmxlLCB0aGVuIHJldHVybiBmb2N1cyB0byB0aGUgb3JpZ2luYWwgbm9kZSBmb2N1c2VkXG4gICAgICAgIC8vICBvbiBhY3RpdmF0aW9uIChvciB0aGUgY29uZmlndXJlZCBgc2V0UmV0dXJuRm9jdXNgIG5vZGUpXG4gICAgICAgIC8vIE5PVEU6IGJ5IHNldHRpbmcgYHJldHVybkZvY3VzOiBmYWxzZWAsIGRlYWN0aXZhdGUoKSB3aWxsIGRvIG5vdGhpbmcsXG4gICAgICAgIC8vICB3aGljaCB3aWxsIHJlc3VsdCBpbiB0aGUgb3V0c2lkZSBjbGljayBzZXR0aW5nIGZvY3VzIHRvIHRoZSBub2RlXG4gICAgICAgIC8vICB0aGF0IHdhcyBjbGlja2VkLCB3aGV0aGVyIGl0J3MgZm9jdXNhYmxlIG9yIG5vdDsgYnkgc2V0dGluZ1xuICAgICAgICAvLyAgYHJldHVybkZvY3VzOiB0cnVlYCwgd2UnbGwgYXR0ZW1wdCB0byByZS1mb2N1cyB0aGUgbm9kZSBvcmlnaW5hbGx5LWZvY3VzZWRcbiAgICAgICAgLy8gIG9uIGFjdGl2YXRpb24gKG9yIHRoZSBjb25maWd1cmVkIGBzZXRSZXR1cm5Gb2N1c2Agbm9kZSlcbiAgICAgICAgcmV0dXJuRm9jdXM6IGNvbmZpZy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSAmJiAhaXNGb2N1c2FibGUoZS50YXJnZXQpXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRoaXMgaXMgbmVlZGVkIGZvciBtb2JpbGUgZGV2aWNlcy5cbiAgICAvLyAoSWYgd2UnbGwgb25seSBsZXQgYGNsaWNrYCBldmVudHMgdGhyb3VnaCxcbiAgICAvLyB0aGVuIG9uIG1vYmlsZSB0aGV5IHdpbGwgYmUgYmxvY2tlZCBhbnl3YXlzIGlmIGB0b3VjaHN0YXJ0YCBpcyBibG9ja2VkLilcblxuXG4gICAgaWYgKGNvbmZpZy5hbGxvd091dHNpZGVDbGljayAmJiAodHlwZW9mIGNvbmZpZy5hbGxvd091dHNpZGVDbGljayA9PT0gJ2Jvb2xlYW4nID8gY29uZmlnLmFsbG93T3V0c2lkZUNsaWNrIDogY29uZmlnLmFsbG93T3V0c2lkZUNsaWNrKGUpKSkge1xuICAgICAgLy8gYWxsb3cgdGhlIGNsaWNrIG91dHNpZGUgdGhlIHRyYXAgdG8gdGFrZSBwbGFjZVxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gb3RoZXJ3aXNlLCBwcmV2ZW50IHRoZSBjbGlja1xuXG5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0gLy8gSW4gY2FzZSBmb2N1cyBlc2NhcGVzIHRoZSB0cmFwIGZvciBzb21lIHN0cmFuZ2UgcmVhc29uLCBwdWxsIGl0IGJhY2sgaW4uXG5cblxuICBmdW5jdGlvbiBjaGVja0ZvY3VzSW4oZSkge1xuICAgIC8vIEluIEZpcmVmb3ggd2hlbiB5b3UgVGFiIG91dCBvZiBhbiBpZnJhbWUgdGhlIERvY3VtZW50IGlzIGJyaWVmbHkgZm9jdXNlZC5cbiAgICBpZiAoY29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSB8fCBlLnRhcmdldCBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB0cnlGb2N1cyhzdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSB8fCBnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tLZXkoZSkge1xuICAgIGlmIChjb25maWcuZXNjYXBlRGVhY3RpdmF0ZXMgIT09IGZhbHNlICYmIGlzRXNjYXBlRXZlbnQoZSkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRlYWN0aXZhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNUYWJFdmVudChlKSkge1xuICAgICAgY2hlY2tUYWIoZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IC8vIEhpamFjayBUYWIgZXZlbnRzIG9uIHRoZSBmaXJzdCBhbmQgbGFzdCBmb2N1c2FibGUgbm9kZXMgb2YgdGhlIHRyYXAsXG4gIC8vIGluIG9yZGVyIHRvIHByZXZlbnQgZm9jdXMgZnJvbSBlc2NhcGluZy4gSWYgaXQgZXNjYXBlcyBmb3IgZXZlbiBhXG4gIC8vIG1vbWVudCBpdCBjYW4gZW5kIHVwIHNjcm9sbGluZyB0aGUgcGFnZSBhbmQgY2F1c2luZyBjb25mdXNpb24gc28gd2VcbiAgLy8ga2luZCBvZiBuZWVkIHRvIGNhcHR1cmUgdGhlIGFjdGlvbiBhdCB0aGUga2V5ZG93biBwaGFzZS5cblxuXG4gIGZ1bmN0aW9uIGNoZWNrVGFiKGUpIHtcbiAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG5cbiAgICBpZiAoZS5zaGlmdEtleSAmJiBlLnRhcmdldCA9PT0gc3RhdGUuZmlyc3RUYWJiYWJsZU5vZGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRyeUZvY3VzKHN0YXRlLmxhc3RUYWJiYWJsZU5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZS5zaGlmdEtleSAmJiBlLnRhcmdldCA9PT0gc3RhdGUubGFzdFRhYmJhYmxlTm9kZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdHJ5Rm9jdXMoc3RhdGUuZmlyc3RUYWJiYWJsZU5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrQ2xpY2soZSkge1xuICAgIGlmIChjb25maWcuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMpIHJldHVybjtcbiAgICBpZiAoY29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuXG4gICAgaWYgKGNvbmZpZy5hbGxvd091dHNpZGVDbGljayAmJiAodHlwZW9mIGNvbmZpZy5hbGxvd091dHNpZGVDbGljayA9PT0gJ2Jvb2xlYW4nID8gY29uZmlnLmFsbG93T3V0c2lkZUNsaWNrIDogY29uZmlnLmFsbG93T3V0c2lkZUNsaWNrKGUpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGFiYmFibGVOb2RlcygpIHtcbiAgICB2YXIgdGFiYmFibGVOb2RlcyA9IHRhYmJhYmxlKGNvbnRhaW5lcik7XG4gICAgc3RhdGUuZmlyc3RUYWJiYWJsZU5vZGUgPSB0YWJiYWJsZU5vZGVzWzBdIHx8IGdldEluaXRpYWxGb2N1c05vZGUoKTtcbiAgICBzdGF0ZS5sYXN0VGFiYmFibGVOb2RlID0gdGFiYmFibGVOb2Rlc1t0YWJiYWJsZU5vZGVzLmxlbmd0aCAtIDFdIHx8IGdldEluaXRpYWxGb2N1c05vZGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeUZvY3VzKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVybjtcblxuICAgIGlmICghbm9kZSB8fCAhbm9kZS5mb2N1cykge1xuICAgICAgdHJ5Rm9jdXMoZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLmZvY3VzKHtcbiAgICAgIHByZXZlbnRTY3JvbGw6ICEhY29uZmlnLnByZXZlbnRTY3JvbGxcbiAgICB9KTtcbiAgICBzdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSA9IG5vZGU7XG5cbiAgICBpZiAoaXNTZWxlY3RhYmxlSW5wdXQobm9kZSkpIHtcbiAgICAgIG5vZGUuc2VsZWN0KCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2VsZWN0YWJsZUlucHV0KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiB0eXBlb2Ygbm9kZS5zZWxlY3QgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzRXNjYXBlRXZlbnQoZSkge1xuICByZXR1cm4gZS5rZXkgPT09ICdFc2NhcGUnIHx8IGUua2V5ID09PSAnRXNjJyB8fCBlLmtleUNvZGUgPT09IDI3O1xufVxuXG5mdW5jdGlvbiBpc1RhYkV2ZW50KGUpIHtcbiAgcmV0dXJuIGUua2V5ID09PSAnVGFiJyB8fCBlLmtleUNvZGUgPT09IDk7XG59XG5cbmZ1bmN0aW9uIGRlbGF5KGZuKSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGZuLCAwKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRm9jdXNUcmFwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy10cmFwLmVzbS5qcy5tYXBcbiIsImltcG9ydCB7IGNyZWF0ZUZvY3VzVHJhcCB9IGZyb20gJ2ZvY3VzLXRyYXAnO1xuaW1wb3J0IHsgS0VZX0NPREUgfSBmcm9tICcuL3V0aWxzL2tleXMnO1xuXG5jb25zdCBCT0RZX09QRU5fQ0xBU1MgPSAnaGFzLW1vZGFsJztcbmNvbnN0IE1PREFMX09QRU5fQ0xBU1MgPSAnbW9kYWwtLW9wZW4nO1xuY29uc3QgREFUQV9NT0RBTF9UT0dHTEUgPSAnZGF0YS10b2dnbGUtbW9kYWwnO1xuY29uc3QgREFUQV9NT0RBTF9DTE9TRSA9ICdkYXRhLWNsb3NlLW1vZGFsJztcblxuY29uc3QgRVZFTlRfQ0xPU0UgPSAnbW9kYWwuY2xvc2UnO1xuY29uc3QgRVZFTlRfT1BFTiA9ICdtb2RhbC5vcGVuJztcblxubGV0IGFjdGl2ZU1vZGFsID0gbnVsbDtcblxuZXhwb3J0IGNsYXNzIE1vZGFsIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RhbElELCB0b2dnbGVzKSB7XG4gICAgICAgIHRoaXMubW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtb2RhbElEKTtcbiAgICAgICAgdGhpcy5mb2N1c1RyYXAgPSBjcmVhdGVGb2N1c1RyYXAodGhpcy5tb2RhbCk7XG5cbiAgICAgICAgaWYgKHRvZ2dsZXMgJiYgdG9nZ2xlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRUb2dnbGVzKHRvZ2dsZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ldmVudENsb3NlID0gbmV3IEV2ZW50KEVWRU5UX0NMT1NFKTtcbiAgICAgICAgdGhpcy5ldmVudE9wZW4gPSBuZXcgRXZlbnQoRVZFTlRfT1BFTik7XG4gICAgfVxuXG4gICAgaW5pdFRvZ2dsZXModG9nZ2xlcykge1xuICAgICAgICBbLi4udG9nZ2xlc10uZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goKHRvZ2dsZSkgPT4ge1xuICAgICAgICAgICAgdG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB0aGlzLnNob3dNb2RhbChldmVudCkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzaG93TW9kYWwoZXZlbnQpIHtcbiAgICAgICAgYWN0aXZlTW9kYWwgPSB0aGlzO1xuICAgICAgICB0aGlzLmFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLm1vZGFsLmNsYXNzTGlzdC5hZGQoTU9EQUxfT1BFTl9DTEFTUyk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChCT0RZX09QRU5fQ0xBU1MpO1xuICAgICAgICB0aGlzLm1vZGFsLmZvY3VzKCk7XG4gICAgICAgIHRoaXMuZm9jdXNUcmFwLmFjdGl2YXRlKCk7XG4gICAgICAgIC8vIHRoaXMuaGlkZUFsbENvbnRlbnRGb3JTY3JlZW5SZWFkZXJzKCk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5tb2RhbC5kaXNwYXRjaEV2ZW50KHRoaXMuZXZlbnRPcGVuKTtcbiAgICB9XG5cbiAgICBjbG9zZU1vZGFsKGV2ZW50KSB7XG4gICAgICAgIGFjdGl2ZU1vZGFsLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShCT0RZX09QRU5fQ0xBU1MpO1xuICAgICAgICBhY3RpdmVNb2RhbC5tb2RhbC5jbGFzc0xpc3QucmVtb3ZlKE1PREFMX09QRU5fQ0xBU1MpO1xuICAgICAgICBhY3RpdmVNb2RhbC5mb2N1c1RyYXAuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAvLyB0aGlzLnNob3dBbGxDb250ZW50Rm9yU2NyZWVuUmVhZGVycygpO1xuICAgICAgICBpZiAoYWN0aXZlTW9kYWwuYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVNb2RhbC5hY3RpdmVFbGVtZW50LmZvY3VzKSB7XG4gICAgICAgICAgICBhY3RpdmVNb2RhbC5hY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlTW9kYWwubW9kYWwuZGlzcGF0Y2hFdmVudChhY3RpdmVNb2RhbC5ldmVudENsb3NlKTtcbiAgICAgICAgYWN0aXZlTW9kYWwgPSBudWxsO1xuICAgIH1cblxuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLm1vZGFsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZU1vZGFsQ2xpY2spO1xuICAgICAgICB0aGlzLm1vZGFsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVNb2RhbENsaWNrKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLmhhbmRsZURvY3VtZW50S2V5VXBFdmVudCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMubW9kYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlTW9kYWxDbGljayk7XG4gICAgICAgIHRoaXMubW9kYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZU1vZGFsQ2xpY2spO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudEtleVVwRXZlbnQpO1xuICAgIH1cblxuICAgIGhhbmRsZURvY3VtZW50S2V5VXBFdmVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gS0VZX0NPREUuRVNDKSB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGFjdGl2ZU1vZGFsLmNsb3NlTW9kYWwoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlTW9kYWxDbGljayhldmVudCkge1xuICAgICAgICBjb25zdCBjbG9zZUF0dHIgPSBgWyR7REFUQV9NT0RBTF9DTE9TRX1dYDtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldC5oYXNBdHRyaWJ1dGUoY2xvc2VBdHRyKSB8fCBldmVudC50YXJnZXQuY2xvc2VzdChjbG9zZUF0dHIpKSB7XG4gICAgICAgICAgICBhY3RpdmVNb2RhbC5jbG9zZU1vZGFsKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhpZGVBbGxDb250ZW50Rm9yU2NyZWVuUmVhZGVycygpIHtcbiAgICAgICAgWy4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW5dLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgIT09IHRoaXMubW9kYWwpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNob3dBbGxDb250ZW50Rm9yU2NyZWVuUmVhZGVycygpIHtcbiAgICAgICAgWy4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW5dLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgIT09IHRoaXMubW9kYWwpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY29uc3QgZ2VuZXJhdGVNb2RhbHNUb2dnbGVzTWFwID0gKHRvZ2dsZXMpID0+IHtcbiAgICBjb25zdCBtYXAgPSBbXTtcblxuICAgIHRvZ2dsZXMuZm9yRWFjaCgodG9nZ2xlKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vZGFsSUQgPSB0b2dnbGUuZ2V0QXR0cmlidXRlKERBVEFfTU9EQUxfVE9HR0xFKTtcbiAgICAgICAgaWYgKG1hcFttb2RhbElEXSA9PT0gdW5kZWZpbmVkKSBtYXBbbW9kYWxJRF0gPSBbXTtcbiAgICAgICAgbWFwW21vZGFsSURdLnB1c2godG9nZ2xlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBtYXA7XG59O1xuXG5leHBvcnQgY29uc3QgaW5pdE1vZGFscyA9ICgpID0+IHtcbiAgICBjb25zdCB0b2dnbGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgWyR7REFUQV9NT0RBTF9UT0dHTEV9XWApO1xuICAgIGNvbnN0IG1vZGFsc1RvZ2dsZXNNYXAgPSBnZW5lcmF0ZU1vZGFsc1RvZ2dsZXNNYXAodG9nZ2xlcyk7XG5cbiAgICBPYmplY3Qua2V5cyhtb2RhbHNUb2dnbGVzTWFwKS5mb3JFYWNoKChtb2RhbElEKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvZ2dsZXMgPSBtb2RhbHNUb2dnbGVzTWFwW21vZGFsSURdO1xuICAgICAgICBuZXcgTW9kYWwobW9kYWxJRCwgdG9nZ2xlcyk7XG4gICAgfSk7XG59O1xuIiwiY29uc3QgU0VMRUNUT1JfSU5QVVRfV1JBUFBFUiA9ICcuZm9ybS1maWVsZCc7XG5jb25zdCBTRUxFQ1RPUl9JTlBVVCA9ICcuZm9ybS1maWVsZF9faW5wdXQnO1xuY29uc3QgU0VMRUNUT1JfRVJST1IgPSAnLmZvcm0tZmllbGRfX2Vycm9yJztcbmNvbnN0IENMQVNTX0xBQkVMX0FCT1ZFID0gJ2Zvcm0tZmllbGRfX2xhYmVsLS1hYm92ZSc7XG5jb25zdCBDTEFTU19JTlZBTElEID0gJ2Zvcm0tZmllbGQtLWludmFsaWQnO1xuY29uc3QgSURfRVJST1JfQUxFUlQgPSAnbG9naW5Gb3JtRXJvcnInO1xuXG5mdW5jdGlvbiBoYW5kbGVJbnB1dEV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIGNoYW5nZUZsb2F0TGFiZWxTdGF0ZSh0YXJnZXQpO1xufVxuXG5mdW5jdGlvbiBjaGFuZ2VGbG9hdExhYmVsU3RhdGUoaW5wdXQpIHtcbiAgICBjb25zdCBsYWJlbCA9IGlucHV0LmxhYmVscyA/IGlucHV0LmxhYmVsc1swXSA6IG51bGw7XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICAgIGNvbnN0IGlzTGFiZWxBYm92ZSA9IGlucHV0LnZhbHVlIHx8IGlucHV0ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBpc0xhYmVsQWJvdmUgPyBsYWJlbC5jbGFzc0xpc3QuYWRkKENMQVNTX0xBQkVMX0FCT1ZFKSA6IGxhYmVsLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTEFCRUxfQUJPVkUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSZXF1aXJlZElucHV0KGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dC52YWx1ZSkge1xuICAgICAgICBzZXRJbnZhbGlkU3RhdGUoaW5wdXQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNldEludmFsaWRTdGF0ZShpbnB1dCkge1xuICAgIGNvbnN0IHdyYXBwZXIgPSBpbnB1dC5jbG9zZXN0KFNFTEVDVE9SX0lOUFVUX1dSQVBQRVIpO1xuICAgIGNvbnN0IGVycm9yID0gd3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0VSUk9SKVswXTtcbiAgICB3cmFwcGVyLmNsYXNzTGlzdC5hZGQoQ0xBU1NfSU5WQUxJRCk7XG4gICAgZXJyb3IucmVtb3ZlQXR0cmlidXRlKCdoaWRkZW4nKTtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCBlcnJvci5pZCk7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gcmVzZXRJbnZhbGlkU3RhdGUoaW5wdXQpIHtcbiAgICBjb25zdCB3cmFwcGVyID0gaW5wdXQuY2xvc2VzdChTRUxFQ1RPUl9JTlBVVF9XUkFQUEVSKTtcbiAgICBjb25zdCBlcnJvciA9IHdyYXBwZXIucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9FUlJPUilbMF07XG4gICAgd3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX0lOVkFMSUQpO1xuICAgIGVycm9yLnNldEF0dHJpYnV0ZSgnaGlkZGVuJywgJ2hpZGRlbicpO1xuICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpO1xuICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJyk7XG59XG5cbmZ1bmN0aW9uIGluaXRJbnB1dHMoKSB7XG4gICAgY29uc3QgaW5wdXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9JTlBVVCk7XG4gICAgWy4uLmlucHV0c10uZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgaGFuZGxlSW5wdXRFdmVudCk7XG4gICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgaGFuZGxlSW5wdXRFdmVudCk7XG4gICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVJbnB1dEV2ZW50KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaW5pdExvZ2luRm9ybSgpIHtcbiAgICBjb25zdCBsb2dpbk1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZ2luTW9kYWwnKTtcbiAgICBjb25zdCBsb2dpbkZvcm0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9naW5Gb3JtJyk7XG4gICAgY29uc3QgaW5wdXRzID0gbG9naW5Gb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfSU5QVVQpO1xuXG4gICAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGxvZ2luTW9kYWwuYWRkRXZlbnRMaXN0ZW5lcignbW9kYWwuY2xvc2UnLCAoZSkgPT4gcmVzZXRGb3JtSW52YWxpZFN0YXRlKCkpO1xuICAgICAgICBsb2dpbkZvcm0uYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0Jywgc3VibWl0Rm9ybSk7XG5cbiAgICAgICAgWy4uLmlucHV0c10uZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnRhcmdldC52YWx1ZSAmJiByZXNldEludmFsaWRTdGF0ZShlLnRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VibWl0Rm9ybShldmVudCkge1xuICAgICAgICByZW1vdmVFcnJvckFsZXJ0KCk7XG4gICAgICAgIGNvbnN0IGlzRm9ybVZhbGlkID0gdmFsaWRhdGVGb3JtKCk7XG5cbiAgICAgICAgaWYgKGlzRm9ybVZhbGlkKSB7XG4gICAgICAgICAgICBsb2dpbk1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWNsb3NlLW1vZGFsXScpLmNsaWNrKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY29uc3QgaW52YWxpZEZpZWxkcyA9IGxvZ2luRm9ybS5xdWVyeVNlbGVjdG9yQWxsKCdbYXJpYS1pbnZhbGlkXScpO1xuICAgICAgICAgICAgY3JlYXRlRXJyb3JBbGVydChpbnZhbGlkRmllbGRzLmxlbmd0aCk7XG4gICAgICAgICAgICAvLyBpbnZhbGlkRmllbGRzWzBdLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm0oKSB7XG4gICAgICAgIGxldCBpc0Zvcm1WYWxpZCA9IHRydWU7XG4gICAgICAgIFsuLi5pbnB1dHNdLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdGVSZXF1aXJlZElucHV0KGlucHV0KTtcbiAgICAgICAgICAgICFpc1ZhbGlkICYmIChpc0Zvcm1WYWxpZCA9IGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGlzRm9ybVZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVycm9yQWxlcnQobnVtT2ZJbnZhbGlkRmllbGRzKSB7XG4gICAgICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoSURfRVJST1JfQUxFUlQpKSB7XG4gICAgICAgICAgICBjb25zdCBhbGVydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgYWxlcnQuc2V0QXR0cmlidXRlKCdpZCcsIElEX0VSUk9SX0FMRVJUKTtcbiAgICAgICAgICAgIGFsZXJ0LnNldEF0dHJpYnV0ZSgncm9sZScsICdhbGVydCcpO1xuICAgICAgICAgICAgYWxlcnQuc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsICctMScpO1xuICAgICAgICAgICAgYWxlcnQuY2xhc3NMaXN0LmFkZCgndmlzdWFsbHktaGlkZGVuJyk7XG4gICAgICAgICAgICBhbGVydC5pbm5lckhUTUwgPSBg0KTQvtGA0LzQsCDQvdC1INCx0YvQu9CwINC+0YLQv9GA0LDQstC70LXQvdCwLiDQndCw0LnQtNC10L3QviAke251bU9mSW52YWxpZEZpZWxkc30g0L7RiNC40LHQvtC6LmA7XG4gICAgICAgICAgICBsb2dpbkZvcm0uYXBwZW5kQ2hpbGQoYWxlcnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRXJyb3JBbGVydCgpIHtcbiAgICAgICAgY29uc3QgYWxlcnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChJRF9FUlJPUl9BTEVSVCk7XG4gICAgICAgIGlmIChhbGVydCkge1xuICAgICAgICAgICAgYWxlcnQucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldEZvcm1JbnZhbGlkU3RhdGUoKSB7XG4gICAgICAgIFsuLi5pbnB1dHNdLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXNldEludmFsaWRTdGF0ZShpbnB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZW1vdmVFcnJvckFsZXJ0KCk7XG4gICAgfVxuXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbn1cblxuZXhwb3J0IGNvbnN0IGluaXRGb3JtcyA9ICgpID0+IHtcbiAgICBpbml0SW5wdXRzKCk7XG4gICAgaW5pdExvZ2luRm9ybSgpO1xufTtcbiIsImltcG9ydCB7IGluaXRUYWJzIH0gZnJvbSAnLi90YWJzJztcbmltcG9ydCB7IGluaXRNb2RhbHMgfSBmcm9tICcuL21vZGFsJztcbmltcG9ydCB7IGluaXRGb3JtcyB9IGZyb20gJy4vZm9ybXMnO1xuXG5jbGFzcyBBcHAge1xuICAgIGNvbnN0cnVjdG9yKCkge31cbiAgICBpbml0KCkge1xuICAgICAgICBpbml0TW9kYWxzKCk7XG4gICAgICAgIGluaXRUYWJzKCk7XG4gICAgICAgIGluaXRGb3JtcygpO1xuICAgIH1cbn1cblxuY29uc3QgYXBwID0gbmV3IEFwcCgpO1xuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IGFwcC5pbml0KCkpO1xuIiwiaW1wb3J0ICcuL3N0eWxlcy9pbmRleC5zY3NzJztcbmltcG9ydCAnLi9zY3JpcHRzL2FwcCc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")}]);