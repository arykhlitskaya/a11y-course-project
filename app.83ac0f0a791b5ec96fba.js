!function(Q){var n={};function F(B){if(n[B])return n[B].exports;var t=n[B]={i:B,l:!1,exports:{}};return Q[B].call(t.exports,t,t.exports,F),t.l=!0,t.exports}F.m=Q,F.c=n,F.d=function(Q,n,B){F.o(Q,n)||Object.defineProperty(Q,n,{enumerable:!0,get:B})},F.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},F.t=function(Q,n){if(1&n&&(Q=F(Q)),8&n)return Q;if(4&n&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var B=Object.create(null);if(F.r(B),Object.defineProperty(B,"default",{enumerable:!0,value:Q}),2&n&&"string"!=typeof Q)for(var t in Q)F.d(B,t,function(n){return Q[n]}.bind(null,t));return B},F.n=function(Q){var n=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return F.d(n,"a",n),n},F.o=function(Q,n){return Object.prototype.hasOwnProperty.call(Q,n)},F.p="",F(F.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/styles/index.scss\n// extracted by mini-css-extract-plugin\n\n// CONCATENATED MODULE: ./src/scripts/utils/keys.js\nconst KEY_CODE = {\n  TAB: 9,\n  ESC: 27,\n  END: 35,\n  HOME: 36,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40\n};\n// CONCATENATED MODULE: ./src/scripts/tabs.js\n\nconst SELECTOR_TAB = '[role=\"tab\"]';\nconst SELECTOR_TABS_CONTAINER = '.tabs';\nconst SELECTOR_TAB_PANEL = '[role=\"tabpanel\"]';\nconst SELECTOR_TAB_LIST = '[role=\"tablist\"]';\nconst CLASS_TAB_ACTIVE = 'active';\n\nconst Tabs = tabContainer => {\n  let tablist = tabContainer.querySelectorAll(SELECTOR_TAB_LIST)[0];\n  let tabs = tabContainer.querySelectorAll(SELECTOR_TAB);\n  let panels = tabContainer.querySelectorAll(SELECTOR_TAB_PANEL);\n  let isVerticalOrientation = tablist.getAttribute('aria-orientation') === 'vertical'; // Bind listeners\n\n  for (let i = 0; i < tabs.length; ++i) {\n    addListeners(i);\n  }\n\n  function addListeners(index) {\n    tabs[index].addEventListener('click', clickEventListener);\n    tabs[index].addEventListener('keydown', keydownEventListener);\n    tabs[index].addEventListener('keyup', keyupEventListener);\n    tabs[index].index = index;\n  } // When a tab is clicked, activateTab is fired to activate it\n\n\n  function clickEventListener(event) {\n    let tab = event.target;\n    activateTab(tab, false);\n  } // Handle keydown on tabs\n\n\n  function keydownEventListener(event) {\n    switch (event.keyCode) {\n      case KEY_CODE.END:\n        event.preventDefault();\n        activateTab(tabs[tabs.length - 1]);\n        break;\n\n      case KEY_CODE.HOME:\n        event.preventDefault();\n        activateTab(tabs[0]);\n        break;\n      // Up and down are in keydown\n      // because we need to prevent page scroll >:)\n\n      case KEY_CODE.UP:\n      case KEY_CODE.DOWN:\n        determineOrientation(event);\n        break;\n    }\n  } // Handle keyup on tabs\n\n\n  function keyupEventListener(event) {\n    switch (event.keyCode) {\n      case KEY_CODE.LEFT:\n      case KEY_CODE.RIGHT:\n        determineOrientation(event);\n        break;\n    }\n  } // When a tablistâ€™s aria-orientation is set to vertical,\n  // only up and down arrow should function.\n  // In all other cases only left and right arrow function.\n\n\n  function determineOrientation(event) {\n    let key = event.keyCode;\n\n    if (isVerticalOrientation && (key === KEY_CODE.UP || key === KEY_CODE.DOWN)) {\n      event.preventDefault();\n      switchTabOnArrowPress(event);\n    } else if (!isVerticalOrientation && (key === KEY_CODE.LEFT || key === KEY_CODE.RIGHT)) {\n      switchTabOnArrowPress(event);\n    }\n  } // Either focus the next, previous, first, or last tab\n  // depening on key pressed\n\n\n  function switchTabOnArrowPress(event) {\n    const pressed = event.keyCode;\n    const target = event.target;\n\n    for (let x = 0; x < tabs.length; x++) {\n      tabs[x].addEventListener('focus', focusEventHandler);\n    }\n\n    const direction = pressed === KEY_CODE.UP || pressed === KEY_CODE.LEFT ? -1 : pressed === KEY_CODE.DOWN || pressed === KEY_CODE.RIGHT ? 1 : 0;\n\n    if (direction !== 0 && target.index !== undefined) {\n      const newIndex = target.index + direction;\n      const activeIndex = newIndex < 0 ? tabs.length - 1 : newIndex < tabs.length ? newIndex : 0;\n      tabs[activeIndex].focus();\n    }\n  } // Activates any given tab panel\n\n\n  function activateTab(tab, setFocus) {\n    setFocus = setFocus || true; // Deactivate all other tabs\n\n    deactivateTabs();\n    tab.removeAttribute('tabindex');\n    tab.setAttribute('aria-selected', 'true');\n    tab.classList.add(CLASS_TAB_ACTIVE);\n    const panelId = tab.getAttribute('aria-controls');\n    document.getElementById(panelId).removeAttribute('hidden'); // Set focus when required\n\n    if (setFocus) {\n      tab.focus();\n    }\n  } // Deactivate all tabs and tab panels\n\n\n  function deactivateTabs() {\n    [...tabs].forEach(tab => {\n      tab.setAttribute('tabindex', '-1');\n      tab.setAttribute('aria-selected', 'false');\n      tab.classList.remove(CLASS_TAB_ACTIVE);\n      tab.removeEventListener('focus', focusEventHandler);\n    });\n    [...panels].forEach(panel => {\n      panel.setAttribute('hidden', 'hidden');\n    });\n  }\n\n  function focusEventHandler(event) {\n    let target = event.target;\n    activateTab(target, false);\n  }\n};\n\nconst initTabs = () => {\n  const tabs = document.querySelectorAll(SELECTOR_TABS_CONTAINER);\n  [...tabs].forEach(tabConatiner => {\n    Tabs(tabConatiner);\n  });\n};\n// CONCATENATED MODULE: ./node_modules/tabbable/dist/index.esm.js\n/*!\n* tabbable 5.1.2\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\nvar candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])', 'details>summary'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar matches = typeof Element === 'undefined' ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable);\n  candidates.forEach(function (candidate, i) {\n    var candidateTabindex = getTabindex(candidate);\n\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate\n      });\n    }\n  });\n  var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function (a) {\n    return a.node;\n  }).concat(regularTabbables);\n  return tabbableNodes;\n}\n\nfunction focusable(el, options) {\n  options = options || {};\n  var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable);\n  return candidates;\n}\n\nfunction getCandidates(el, includeContainer, filter) {\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n\n  candidates = candidates.filter(filter);\n  return candidates;\n}\n\nfunction isNodeMatchingSelectorTabbable(node) {\n  if (!isNodeMatchingSelectorFocusable(node) || isNonTabbableRadio(node) || getTabindex(node) < 0) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isTabbable(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorTabbable(node);\n}\n\nfunction isNodeMatchingSelectorFocusable(node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node)) {\n    return false;\n  }\n\n  return true;\n}\n\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\n\nfunction isFocusable(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorFocusable(node);\n}\n\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n\n  if (!isNaN(tabindexAttr)) {\n    return tabindexAttr;\n  } // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n\n\n  if (isContentEditable(node)) {\n    return 0;\n  } // in Chrome, <audio controls/> and <video controls/> elements get a default\n  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n  //  yet they are still part of the regular tab order; in FF, they get a default\n  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n  //  order, consider their tab index to be 0\n\n\n  if ((node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO') && node.getAttribute('tabindex') === null) {\n    return 0;\n  }\n\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n\n  var radioScope = node.form || node.ownerDocument;\n  var radioSet = radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n}\n\nfunction isHidden(node) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n\n  while (node) {\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement;\n  }\n\n  return false;\n}\n\n\n//# sourceMappingURL=index.esm.js.map\n\n// CONCATENATED MODULE: ./node_modules/focus-trap/dist/focus-trap.esm.js\n/*!\n* focus-trap 6.1.3\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\n\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar activeFocusDelay;\n\nvar activeFocusTraps = function () {\n  var trapQueue = [];\n  return {\n    activateTrap: function activateTrap(trap) {\n      if (trapQueue.length > 0) {\n        var activeTrap = trapQueue[trapQueue.length - 1];\n\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n    deactivateTrap: function deactivateTrap(trap) {\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    }\n  };\n}();\n\nfunction createFocusTrap(element, userOptions) {\n  var doc = document;\n  var container = typeof element === 'string' ? doc.querySelector(element) : element;\n\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true\n  }, userOptions);\n\n  var state = {\n    firstTabbableNode: null,\n    lastTabbableNode: null,\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false\n  };\n  var trap = {\n    activate: activate,\n    deactivate: deactivate,\n    pause: pause,\n    unpause: unpause\n  };\n  return trap;\n\n  function activate(activateOptions) {\n    if (state.active) return;\n    updateTabbableNodes();\n    state.active = true;\n    state.paused = false;\n    state.nodeFocusedBeforeActivation = doc.activeElement;\n    var onActivate = activateOptions && activateOptions.onActivate ? activateOptions.onActivate : config.onActivate;\n\n    if (onActivate) {\n      onActivate();\n    }\n\n    addListeners();\n    return trap;\n  }\n\n  function deactivate(deactivateOptions) {\n    if (!state.active) return;\n    clearTimeout(activeFocusDelay);\n    removeListeners();\n    state.active = false;\n    state.paused = false;\n    activeFocusTraps.deactivateTrap(trap);\n    var onDeactivate = deactivateOptions && deactivateOptions.onDeactivate !== undefined ? deactivateOptions.onDeactivate : config.onDeactivate;\n\n    if (onDeactivate) {\n      onDeactivate();\n    }\n\n    var returnFocus = deactivateOptions && deactivateOptions.returnFocus !== undefined ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate;\n\n    if (returnFocus) {\n      delay(function () {\n        tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n      });\n    }\n\n    return trap;\n  }\n\n  function pause() {\n    if (state.paused || !state.active) return;\n    state.paused = true;\n    removeListeners();\n  }\n\n  function unpause() {\n    if (!state.paused || !state.active) return;\n    state.paused = false;\n    updateTabbableNodes();\n    addListeners();\n  }\n\n  function addListeners() {\n    if (!state.active) return; // There can be only one listening focus trap at a time\n\n    activeFocusTraps.activateTrap(trap); // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n\n    activeFocusDelay = config.delayInitialFocus ? delay(function () {\n      tryFocus(getInitialFocusNode());\n    }) : tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n    return trap;\n  }\n\n  function removeListeners() {\n    if (!state.active) return;\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n    return trap;\n  }\n\n  function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n    var node = optionValue;\n\n    if (!optionValue) {\n      return null;\n    }\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue);\n\n      if (!node) {\n        throw new Error('`' + optionName + '` refers to no known node');\n      }\n    }\n\n    if (typeof optionValue === 'function') {\n      node = optionValue();\n\n      if (!node) {\n        throw new Error('`' + optionName + '` did not return a node');\n      }\n    }\n\n    return node;\n  }\n\n  function getInitialFocusNode() {\n    var node;\n\n    if (getNodeForOption('initialFocus') !== null) {\n      node = getNodeForOption('initialFocus');\n    } else if (container.contains(doc.activeElement)) {\n      node = doc.activeElement;\n    } else {\n      node = state.firstTabbableNode || getNodeForOption('fallbackFocus');\n    }\n\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n\n    return node;\n  }\n\n  function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus');\n    return node ? node : previousActiveElement;\n  } // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n\n\n  function checkPointerDown(e) {\n    if (container.contains(e.target)) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n\n    if (config.clickOutsideDeactivates) {\n      // immediately deactivate the trap\n      deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus: config.returnFocusOnDeactivate && !isFocusable(e.target)\n      });\n      return;\n    } // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n\n\n    if (config.allowOutsideClick && (typeof config.allowOutsideClick === 'boolean' ? config.allowOutsideClick : config.allowOutsideClick(e))) {\n      // allow the click outside the trap to take place\n      return;\n    } // otherwise, prevent the click\n\n\n    e.preventDefault();\n  } // In case focus escapes the trap for some strange reason, pull it back in.\n\n\n  function checkFocusIn(e) {\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (container.contains(e.target) || e.target instanceof Document) {\n      return;\n    }\n\n    e.stopImmediatePropagation();\n    tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n  }\n\n  function checkKey(e) {\n    if (config.escapeDeactivates !== false && isEscapeEvent(e)) {\n      e.preventDefault();\n      deactivate();\n      return;\n    }\n\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  } // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n\n\n  function checkTab(e) {\n    updateTabbableNodes();\n\n    if (e.shiftKey && e.target === state.firstTabbableNode) {\n      e.preventDefault();\n      tryFocus(state.lastTabbableNode);\n      return;\n    }\n\n    if (!e.shiftKey && e.target === state.lastTabbableNode) {\n      e.preventDefault();\n      tryFocus(state.firstTabbableNode);\n      return;\n    }\n  }\n\n  function checkClick(e) {\n    if (config.clickOutsideDeactivates) return;\n    if (container.contains(e.target)) return;\n\n    if (config.allowOutsideClick && (typeof config.allowOutsideClick === 'boolean' ? config.allowOutsideClick : config.allowOutsideClick(e))) {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  }\n\n  function updateTabbableNodes() {\n    var tabbableNodes = tabbable(container);\n    state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();\n    state.lastTabbableNode = tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();\n  }\n\n  function tryFocus(node) {\n    if (node === doc.activeElement) return;\n\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    state.mostRecentlyFocusedNode = node;\n\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  }\n}\n\nfunction isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n}\n\nfunction isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n}\n\nfunction isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n}\n\nfunction delay(fn) {\n  return setTimeout(fn, 0);\n}\n\n\n//# sourceMappingURL=focus-trap.esm.js.map\n\n// CONCATENATED MODULE: ./src/scripts/utils/focus.js\nconst setFocusOnFirstDescendant = element => {\n  for (let i = 0; i < element.childNodes.length; i++) {\n    const child = element.childNodes[i];\n\n    if (tryToSetFocus(child) || setFocusOnFirstDescendant(child)) {\n      return true;\n    }\n  }\n\n  return false;\n};\nconst setFocusOnLastDescendant = element => {\n  for (let i = element.childNodes.length - 1; i >= 0; i--) {\n    let child = element.childNodes[i];\n\n    if (tryToSetFocus(child) || setFocusOnLastDescendant(child)) {\n      return true;\n    }\n  }\n\n  return false;\n};\nconst tryToSetFocus = function (element) {\n  if (!focus_isFocusable(element)) {\n    return false;\n  }\n\n  try {\n    element.focus();\n  } catch (e) {}\n\n  return document.activeElement === element;\n};\nconst focus_isFocusable = function (element) {\n  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute('tabIndex') !== null) {\n    return true;\n  }\n\n  if (element.disabled) {\n    return false;\n  }\n\n  switch (element.nodeName) {\n    case 'A':\n      return !!element.href && element.rel != 'ignore';\n\n    case 'INPUT':\n      return element.type != 'hidden' && element.type != 'file';\n\n    case 'BUTTON':\n    case 'SELECT':\n    case 'TEXTAREA':\n      return true;\n\n    default:\n      return false;\n  }\n};\n// CONCATENATED MODULE: ./src/scripts/modal.js\n\n\n\nconst BODY_OPEN_CLASS = 'has-modal';\nconst MODAL_OPEN_CLASS = 'modal--open';\nconst DATA_MODAL_TOGGLE = 'data-toggle-modal';\nconst DATA_MODAL_CLOSE = 'data-close-modal';\nconst EVENT_CLOSE = 'modal.close';\nconst EVENT_OPEN = 'modal.open';\nlet activeModal = null; // this.eventClose = new Event(EVENT_CLOSE);\n// this.eventOpen = new Event(EVENT_OPEN);\n\nclass modal_Modal {\n  constructor(modalID, toggles) {\n    this.modal = document.getElementById(modalID);\n    this.focusTrap = createFocusTrap(this.modal);\n\n    if (toggles && toggles.length > 0) {\n      this.initToggles(toggles);\n    }\n\n    this.eventClose = new Event(EVENT_CLOSE);\n    this.eventOpen = new Event(EVENT_OPEN);\n  }\n\n  initToggles(toggles) {\n    [...toggles].filter(Boolean).forEach(toggle => {\n      toggle.addEventListener('click', event => this.showModal(event));\n    });\n  }\n\n  showModal(event) {\n    activeModal = this;\n    this.activeElement = document.activeElement;\n    this.modal.classList.add(MODAL_OPEN_CLASS);\n    document.body.classList.add(BODY_OPEN_CLASS);\n    setFocusOnFirstDescendant(this.modal);\n    this.focusTrap.activate();\n    this.hideAllContentForScreenReaders();\n    this.addEventListeners();\n    this.modal.dispatchEvent(this.eventOpen);\n  }\n\n  closeModal(event) {\n    activeModal.removeEventListeners();\n    document.body.classList.remove(BODY_OPEN_CLASS);\n    activeModal.modal.classList.remove(MODAL_OPEN_CLASS);\n    activeModal.focusTrap.deactivate();\n    this.showAllContentForScreenReaders();\n\n    if (activeModal.activeElement && activeModal.activeElement.focus) {\n      activeModal.activeElement.focus();\n    }\n\n    activeModal.modal.dispatchEvent(activeModal.eventClose);\n    activeModal = null;\n  }\n\n  addEventListeners() {\n    this.modal.addEventListener('touchstart', this.handleModalClick);\n    this.modal.addEventListener('click', this.handleModalClick);\n    document.addEventListener('keyup', this.handleDocumentKeyUpEvent);\n  }\n\n  removeEventListeners() {\n    this.modal.removeEventListener('touchstart', this.handleModalClick);\n    this.modal.removeEventListener('click', this.handleModalClick);\n    document.removeEventListener('keydown', this.handleDocumentKeyUpEvent);\n  }\n\n  handleDocumentKeyUpEvent(event) {\n    if (event.keyCode === KEY_CODE.ESC) {\n      event.stopPropagation();\n      activeModal.closeModal(event);\n    }\n  }\n\n  handleModalClick(event) {\n    const closeAttr = `[${DATA_MODAL_CLOSE}]`;\n\n    if (event.target.hasAttribute(closeAttr) || event.target.closest(closeAttr)) {\n      activeModal.closeModal(event);\n    }\n  }\n\n  hideAllContentForScreenReaders() {\n    [...document.body.children].forEach(child => {\n      if (child !== this.modal) {\n        child.setAttribute('aria-hidden', true);\n      }\n    });\n  }\n\n  showAllContentForScreenReaders() {\n    [...document.body.children].forEach(child => {\n      if (child !== this.modal) {\n        child.removeAttribute('aria-hidden');\n      }\n    });\n  }\n\n}\n\nconst generateModalsTogglesMap = toggles => {\n  const map = [];\n  toggles.forEach(toggle => {\n    const modalID = toggle.getAttribute(DATA_MODAL_TOGGLE);\n    if (map[modalID] === undefined) map[modalID] = [];\n    map[modalID].push(toggle);\n  });\n  return map;\n};\n\nconst initModals = () => {\n  const toggles = document.querySelectorAll(`[${DATA_MODAL_TOGGLE}]`);\n  const modalsTogglesMap = generateModalsTogglesMap(toggles);\n  Object.keys(modalsTogglesMap).forEach(modalID => {\n    const toggles = modalsTogglesMap[modalID];\n    new modal_Modal(modalID, toggles);\n  });\n};\n// CONCATENATED MODULE: ./src/scripts/forms.js\nconst SELECTOR_INPUT_WRAPPER = '.form-field';\nconst SELECTOR_INPUT = '.form-field__input';\nconst SELECTOR_ERROR = '.form-field__error';\nconst CLASS_LABEL_ABOVE = 'form-field__label--above';\nconst CLASS_INVALID = 'form-field--invalid';\n\nfunction handleInputChangeEvent(event) {\n  const target = event.target;\n  changeFloatLabelState(target);\n}\n\nfunction changeFloatLabelState(input) {\n  const label = input.labels ? input.labels[0] : null;\n\n  if (label) {\n    const isLabelAbove = input.value || input === document.activeElement;\n    isLabelAbove ? label.classList.add(CLASS_LABEL_ABOVE) : label.classList.remove(CLASS_LABEL_ABOVE);\n  }\n}\n\nfunction validateRequiredInput(input) {\n  if (!input.value) {\n    setInvalidState(input);\n    return false;\n  }\n\n  return true;\n}\n\nfunction setInvalidState(input) {\n  const wrapper = input.closest(SELECTOR_INPUT_WRAPPER);\n  const error = wrapper.querySelectorAll(SELECTOR_ERROR)[0];\n  wrapper.classList.add(CLASS_INVALID);\n  error.removeAttribute('hidden');\n  input.setAttribute('aria-describedby', error.id);\n  input.setAttribute('aria-invalid', true);\n}\n\nfunction resetInvalidState(input) {\n  const wrapper = input.closest(SELECTOR_INPUT_WRAPPER);\n  const error = wrapper.querySelectorAll(SELECTOR_ERROR)[0];\n  wrapper.classList.remove(CLASS_INVALID);\n  error.setAttribute('hidden', 'hidden');\n  input.removeAttribute('aria-describedby');\n  input.removeAttribute('aria-invalid');\n}\n\nfunction initInputs() {\n  const inputs = document.querySelectorAll(SELECTOR_INPUT);\n  [...inputs].forEach(input => {\n    input.addEventListener('change', handleInputChangeEvent);\n  });\n}\n\nfunction initLoginForm() {\n  const loginModal = document.getElementById('loginModal');\n  const loginForm = document.getElementById('loginForm');\n  const inputs = loginForm.querySelectorAll(SELECTOR_INPUT);\n\n  function addEventListeners() {\n    loginModal.addEventListener('modal.close', e => resetFormInvalidState());\n    loginForm.addEventListener('submit', submitForm);\n    [...inputs].forEach(input => {\n      input.addEventListener('keyup', e => {\n        e.target.value && resetInvalidState(e.target);\n      });\n    });\n  }\n\n  function submitForm(event) {\n    const isFormValid = validateForm();\n\n    if (isFormValid) {\n      loginModal.querySelector('[data-close-modal]').click();\n    } else {\n      event.preventDefault();\n      const invalidFields = loginForm.querySelectorAll('[aria-invalid]');\n      invalidFields[0].focus();\n    }\n  }\n\n  function validateForm() {\n    let isFormValid = true;\n    [...inputs].forEach(input => {\n      const isValid = validateRequiredInput(input);\n      !isValid && (isFormValid = false);\n    });\n    return isFormValid;\n  }\n\n  function resetFormInvalidState() {\n    [...inputs].forEach(input => {\n      resetInvalidState(input);\n    });\n  }\n\n  addEventListeners();\n}\n\nconst initForms = () => {\n  initInputs();\n  initLoginForm();\n};\n// CONCATENATED MODULE: ./src/scripts/app.js\n\n\n\n\nclass app_App {\n  constructor() {}\n\n  init() {\n    initModals();\n    initTabs();\n    initForms();\n  }\n\n}\n\nconst app = new app_App();\ndocument.addEventListener('DOMContentLoaded', () => app.init());\n// CONCATENATED MODULE: ./src/index.js\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL2luZGV4LnNjc3M/NDgwMSIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy91dGlscy9rZXlzLmpzPzA1OWQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvdGFicy5qcz9jYzAzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90YWJiYWJsZS9kaXN0L2luZGV4LmVzbS5qcz82MmY3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mb2N1cy10cmFwL2Rpc3QvZm9jdXMtdHJhcC5lc20uanM/ZTE2YyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy91dGlscy9mb2N1cy5qcz9mNTk4Iiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL21vZGFsLmpzP2EwZWEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvZm9ybXMuanM/YjM5MCIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9hcHAuanM/Y2U0ZCIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6WyJLRVlfQ09ERSIsIlRBQiIsIkVTQyIsIkVORCIsIkhPTUUiLCJMRUZUIiwiVVAiLCJSSUdIVCIsIkRPV04iLCJTRUxFQ1RPUl9UQUIiLCJTRUxFQ1RPUl9UQUJTX0NPTlRBSU5FUiIsIlNFTEVDVE9SX1RBQl9QQU5FTCIsIlNFTEVDVE9SX1RBQl9MSVNUIiwiQ0xBU1NfVEFCX0FDVElWRSIsIlRhYnMiLCJ0YWJDb250YWluZXIiLCJ0YWJsaXN0IiwicXVlcnlTZWxlY3RvckFsbCIsInRhYnMiLCJwYW5lbHMiLCJpc1ZlcnRpY2FsT3JpZW50YXRpb24iLCJnZXRBdHRyaWJ1dGUiLCJpIiwibGVuZ3RoIiwiYWRkTGlzdGVuZXJzIiwiaW5kZXgiLCJhZGRFdmVudExpc3RlbmVyIiwiY2xpY2tFdmVudExpc3RlbmVyIiwia2V5ZG93bkV2ZW50TGlzdGVuZXIiLCJrZXl1cEV2ZW50TGlzdGVuZXIiLCJldmVudCIsInRhYiIsInRhcmdldCIsImFjdGl2YXRlVGFiIiwia2V5Q29kZSIsInByZXZlbnREZWZhdWx0IiwiZGV0ZXJtaW5lT3JpZW50YXRpb24iLCJrZXkiLCJzd2l0Y2hUYWJPbkFycm93UHJlc3MiLCJwcmVzc2VkIiwieCIsImZvY3VzRXZlbnRIYW5kbGVyIiwiZGlyZWN0aW9uIiwidW5kZWZpbmVkIiwibmV3SW5kZXgiLCJhY3RpdmVJbmRleCIsImZvY3VzIiwic2V0Rm9jdXMiLCJkZWFjdGl2YXRlVGFicyIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImNsYXNzTGlzdCIsImFkZCIsInBhbmVsSWQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiZm9yRWFjaCIsInJlbW92ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwYW5lbCIsImluaXRUYWJzIiwidGFiQ29uYXRpbmVyIiwic2V0Rm9jdXNPbkZpcnN0RGVzY2VuZGFudCIsImVsZW1lbnQiLCJjaGlsZE5vZGVzIiwiY2hpbGQiLCJ0cnlUb1NldEZvY3VzIiwic2V0Rm9jdXNPbkxhc3REZXNjZW5kYW50IiwiaXNGb2N1c2FibGUiLCJlIiwiYWN0aXZlRWxlbWVudCIsInRhYkluZGV4IiwiZGlzYWJsZWQiLCJub2RlTmFtZSIsImhyZWYiLCJyZWwiLCJ0eXBlIiwiQk9EWV9PUEVOX0NMQVNTIiwiTU9EQUxfT1BFTl9DTEFTUyIsIkRBVEFfTU9EQUxfVE9HR0xFIiwiREFUQV9NT0RBTF9DTE9TRSIsIkVWRU5UX0NMT1NFIiwiRVZFTlRfT1BFTiIsImFjdGl2ZU1vZGFsIiwiTW9kYWwiLCJjb25zdHJ1Y3RvciIsIm1vZGFsSUQiLCJ0b2dnbGVzIiwibW9kYWwiLCJmb2N1c1RyYXAiLCJjcmVhdGVGb2N1c1RyYXAiLCJpbml0VG9nZ2xlcyIsImV2ZW50Q2xvc2UiLCJFdmVudCIsImV2ZW50T3BlbiIsImZpbHRlciIsIkJvb2xlYW4iLCJ0b2dnbGUiLCJzaG93TW9kYWwiLCJib2R5IiwiYWN0aXZhdGUiLCJoaWRlQWxsQ29udGVudEZvclNjcmVlblJlYWRlcnMiLCJhZGRFdmVudExpc3RlbmVycyIsImRpc3BhdGNoRXZlbnQiLCJjbG9zZU1vZGFsIiwicmVtb3ZlRXZlbnRMaXN0ZW5lcnMiLCJkZWFjdGl2YXRlIiwic2hvd0FsbENvbnRlbnRGb3JTY3JlZW5SZWFkZXJzIiwiaGFuZGxlTW9kYWxDbGljayIsImhhbmRsZURvY3VtZW50S2V5VXBFdmVudCIsInN0b3BQcm9wYWdhdGlvbiIsImNsb3NlQXR0ciIsImhhc0F0dHJpYnV0ZSIsImNsb3Nlc3QiLCJjaGlsZHJlbiIsImdlbmVyYXRlTW9kYWxzVG9nZ2xlc01hcCIsIm1hcCIsInB1c2giLCJpbml0TW9kYWxzIiwibW9kYWxzVG9nZ2xlc01hcCIsIk9iamVjdCIsImtleXMiLCJTRUxFQ1RPUl9JTlBVVF9XUkFQUEVSIiwiU0VMRUNUT1JfSU5QVVQiLCJTRUxFQ1RPUl9FUlJPUiIsIkNMQVNTX0xBQkVMX0FCT1ZFIiwiQ0xBU1NfSU5WQUxJRCIsImhhbmRsZUlucHV0Q2hhbmdlRXZlbnQiLCJjaGFuZ2VGbG9hdExhYmVsU3RhdGUiLCJpbnB1dCIsImxhYmVsIiwibGFiZWxzIiwiaXNMYWJlbEFib3ZlIiwidmFsdWUiLCJ2YWxpZGF0ZVJlcXVpcmVkSW5wdXQiLCJzZXRJbnZhbGlkU3RhdGUiLCJ3cmFwcGVyIiwiZXJyb3IiLCJpZCIsInJlc2V0SW52YWxpZFN0YXRlIiwiaW5pdElucHV0cyIsImlucHV0cyIsImluaXRMb2dpbkZvcm0iLCJsb2dpbk1vZGFsIiwibG9naW5Gb3JtIiwicmVzZXRGb3JtSW52YWxpZFN0YXRlIiwic3VibWl0Rm9ybSIsImlzRm9ybVZhbGlkIiwidmFsaWRhdGVGb3JtIiwicXVlcnlTZWxlY3RvciIsImNsaWNrIiwiaW52YWxpZEZpZWxkcyIsImlzVmFsaWQiLCJpbml0Rm9ybXMiLCJBcHAiLCJpbml0IiwiYXBwIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7OztBQ0FPLE1BQU1BLFFBQVEsR0FBRztBQUNwQkMsS0FBRyxFQUFFLENBRGU7QUFFcEJDLEtBQUcsRUFBRSxFQUZlO0FB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qjs7QUFFOUIsd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0Esd0RB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QUMzQixZQUFNdUIsT0FBTyxHQUFHbEIscUJBQXFCLENBQUNMLEtBQUQsQ0FBckM7QUFDQSxPQUFDdUIsT0FBRCxLQUFhTCxXQUFXLEdBQUcsS0FBM0I7QUFDSCxLQUhEO0FBS0EsV0FBT0EsV0FBUDtBQUNIOztBQUVELFdBQVNGLHFCQUFULEdBQWlDO0FBQzdCLEtBQUMsR0FBR0osTUFBSixFQUFZckYsT0FBWixDQUFxQnlFLEtBQUQsSUFBVztBQUMzQlUsdUJBQWlCLENBQUNWLEtBQUQsQ0FBakI7QUFDSCxLQUZEO0FBR0g7O0FBRUQzQixtQkFBaUI7QUFDcEI7O0FBRU0sTUFBTW1ELFNBQVMsR0FBRyxNQUFNO0FBQzNCYixZQUFVO0FBQ1ZFLGVBQWE7QUFDaEIsQ0FITSxDOztBQ3BHUDtBQUNBO0FBQ0E7O0FBRUEsTUFBTVksT0FBTixDQUFVO0FBQ05yRSxhQUFXLEdBQUcsQ0FBRTs7QUFDaEJzRSxNQUFJLEdBQUc7QUFDSHJDLGNBQVU7QUFDVjFELFlBQVE7QUFDUjZGLGFBQVM7QUFDWjs7QUFOSzs7QUFTVixNQUFNRyxHQUFHLEdBQUcsSUFBSUYsT0FBSixFQUFaO0FBQ0FwRyxRQUFRLENBQUM1QixnQkFBVCxDQUEwQixrQkFBMUIsRUFBOEMsTUFBTWtJLEdBQUcsQ0FBQ0QsSUFBSixFQUFwRCxFOztBQ2RBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCJleHBvcnQgY29uc3QgS0VZX0NPREUgPSB7XG4gICAgVEFCOiA5LFxuICAgIEVTQzogMjcsXG4gICAgRU5EOiAzNSxcbiAgICBIT01FOiAzNixcbiAgICBMRUZUOiAzNyxcbiAgICBVUDogMzgsXG4gICAgUklHSFQ6IDM5LFxuICAgIERPV046IDQwLFxufTtcbiIsImltcG9ydCB7IEtFWV9DT0RFIH0gZnJvbSAnLi91dGlscy9rZXlzJztcblxuY29uc3QgU0VMRUNUT1JfVEFCID0gJ1tyb2xlPVwidGFiXCJdJztcbmNvbnN0IFNFTEVDVE9SX1RBQlNfQ09OVEFJTkVSID0gJy50YWJzJztcbmNvbnN0IFNFTEVDVE9SX1RBQl9QQU5FTCA9ICdbcm9sZT1cInRhYnBhbmVsXCJdJztcbmNvbnN0IFNFTEVDVE9SX1RBQl9MSVNUID0gJ1tyb2xlPVwidGFibGlzdFwiXSc7XG5jb25zdCBDTEFTU19UQUJfQUNUSVZFID0gJ2FjdGl2ZSc7XG5cbmNvbnN0IFRhYnMgPSAodGFiQ29udGFpbmVyKSA9PiB7XG4gICAgbGV0IHRhYmxpc3QgPSB0YWJDb250YWluZXIucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9UQUJfTElTVClbMF07XG4gICAgbGV0IHRhYnMgPSB0YWJDb250YWluZXIucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9UQUIpO1xuICAgIGxldCBwYW5lbHMgPSB0YWJDb250YWluZXIucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9UQUJfUEFORUwpO1xuICAgIGxldCBpc1ZlcnRpY2FsT3JpZW50YXRpb24gPSB0YWJsaXN0LmdldEF0dHJpYnV0ZSgnYXJpYS1vcmllbnRhdGlvbicpID09PSAndmVydGljYWwnO1xuXG4gICAgLy8gQmluZCBsaXN0ZW5lcnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYWRkTGlzdGVuZXJzKGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZExpc3RlbmVycyhpbmRleCkge1xuICAgICAgICB0YWJzW2luZGV4XS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsaWNrRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgIHRhYnNbaW5kZXhdLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlkb3duRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgIHRhYnNbaW5kZXhdLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywga2V5dXBFdmVudExpc3RlbmVyKTtcbiAgICAgICAgdGFic1tpbmRleF0uaW5kZXggPSBpbmRleDtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGEgdGFiIGlzIGNsaWNrZWQsIGFjdGl2YXRlVGFiIGlzIGZpcmVkIHRvIGFjdGl2YXRlIGl0XG4gICAgZnVuY3Rpb24gY2xpY2tFdmVudExpc3RlbmVyKGV2ZW50KSB7XG4gICAgICAgIGxldCB0YWIgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGFjdGl2YXRlVGFiKHRhYiwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBrZXlkb3duIG9uIHRhYnNcbiAgICBmdW5jdGlvbiBrZXlkb3duRXZlbnRMaXN0ZW5lcihldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgS0VZX0NPREUuRU5EOlxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGVUYWIodGFic1t0YWJzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgS0VZX0NPREUuSE9NRTpcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGFjdGl2YXRlVGFiKHRhYnNbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBVcCBhbmQgZG93biBhcmUgaW4ga2V5ZG93blxuICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIHByZXZlbnQgcGFnZSBzY3JvbGwgPjopXG4gICAgICAgICAgICBjYXNlIEtFWV9DT0RFLlVQOlxuICAgICAgICAgICAgY2FzZSBLRVlfQ09ERS5ET1dOOlxuICAgICAgICAgICAgICAgIGRldGVybWluZU9yaWVudGF0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBrZXl1cCBvbiB0YWJzXG4gICAgZnVuY3Rpb24ga2V5dXBFdmVudExpc3RlbmVyKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICAgICAgY2FzZSBLRVlfQ09ERS5MRUZUOlxuICAgICAgICAgICAgY2FzZSBLRVlfQ09ERS5SSUdIVDpcbiAgICAgICAgICAgICAgICBkZXRlcm1pbmVPcmllbnRhdGlvbihldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaGVuIGEgdGFibGlzdMOi4oKs4oSicyBhcmlhLW9yaWVudGF0aW9uIGlzIHNldCB0byB2ZXJ0aWNhbCxcbiAgICAvLyBvbmx5IHVwIGFuZCBkb3duIGFycm93IHNob3VsZCBmdW5jdGlvbi5cbiAgICAvLyBJbiBhbGwgb3RoZXIgY2FzZXMgb25seSBsZWZ0IGFuZCByaWdodCBhcnJvdyBmdW5jdGlvbi5cbiAgICBmdW5jdGlvbiBkZXRlcm1pbmVPcmllbnRhdGlvbihldmVudCkge1xuICAgICAgICBsZXQga2V5ID0gZXZlbnQua2V5Q29kZTtcblxuICAgICAgICBpZiAoaXNWZXJ0aWNhbE9yaWVudGF0aW9uICYmIChrZXkgPT09IEtFWV9DT0RFLlVQIHx8IGtleSA9PT0gS0VZX0NPREUuRE9XTikpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzd2l0Y2hUYWJPbkFycm93UHJlc3MoZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc1ZlcnRpY2FsT3JpZW50YXRpb24gJiYgKGtleSA9PT0gS0VZX0NPREUuTEVGVCB8fCBrZXkgPT09IEtFWV9DT0RFLlJJR0hUKSkge1xuICAgICAgICAgICAgc3dpdGNoVGFiT25BcnJvd1ByZXNzKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVpdGhlciBmb2N1cyB0aGUgbmV4dCwgcHJldmlvdXMsIGZpcnN0LCBvciBsYXN0IHRhYlxuICAgIC8vIGRlcGVuaW5nIG9uIGtleSBwcmVzc2VkXG4gICAgZnVuY3Rpb24gc3dpdGNoVGFiT25BcnJvd1ByZXNzKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHByZXNzZWQgPSBldmVudC5rZXlDb2RlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0YWJzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICB0YWJzW3hdLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZm9jdXNFdmVudEhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID1cbiAgICAgICAgICAgIHByZXNzZWQgPT09IEtFWV9DT0RFLlVQIHx8IHByZXNzZWQgPT09IEtFWV9DT0RFLkxFRlRcbiAgICAgICAgICAgICAgICA/IC0xXG4gICAgICAgICAgICAgICAgOiBwcmVzc2VkID09PSBLRVlfQ09ERS5ET1dOIHx8IHByZXNzZWQgPT09IEtFWV9DT0RFLlJJR0hUXG4gICAgICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICAgICAgOiAwO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gIT09IDAgJiYgdGFyZ2V0LmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGFyZ2V0LmluZGV4ICsgZGlyZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlSW5kZXggPSBuZXdJbmRleCA8IDAgPyB0YWJzLmxlbmd0aCAtIDEgOiBuZXdJbmRleCA8IHRhYnMubGVuZ3RoID8gbmV3SW5kZXggOiAwO1xuICAgICAgICAgICAgdGFic1thY3RpdmVJbmRleF0uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFjdGl2YXRlcyBhbnkgZ2l2ZW4gdGFiIHBhbmVsXG4gICAgZnVuY3Rpb24gYWN0aXZhdGVUYWIodGFiLCBzZXRGb2N1cykge1xuICAgICAgICBzZXRGb2N1cyA9IHNldEZvY3VzIHx8IHRydWU7XG4gICAgICAgIC8vIERlYWN0aXZhdGUgYWxsIG90aGVyIHRhYnNcbiAgICAgICAgZGVhY3RpdmF0ZVRhYnMoKTtcblxuICAgICAgICB0YWIucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICB0YWIuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgJ3RydWUnKTtcbiAgICAgICAgdGFiLmNsYXNzTGlzdC5hZGQoQ0xBU1NfVEFCX0FDVElWRSk7XG5cbiAgICAgICAgY29uc3QgcGFuZWxJZCA9IHRhYi5nZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocGFuZWxJZCkucmVtb3ZlQXR0cmlidXRlKCdoaWRkZW4nKTtcblxuICAgICAgICAvLyBTZXQgZm9jdXMgd2hlbiByZXF1aXJlZFxuICAgICAgICBpZiAoc2V0Rm9jdXMpIHtcbiAgICAgICAgICAgIHRhYi5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVhY3RpdmF0ZSBhbGwgdGFicyBhbmQgdGFiIHBhbmVsc1xuICAgIGZ1bmN0aW9uIGRlYWN0aXZhdGVUYWJzKCkge1xuICAgICAgICBbLi4udGFic10uZm9yRWFjaCgodGFiKSA9PiB7XG4gICAgICAgICAgICB0YWIuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgICAgdGFiLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsICdmYWxzZScpO1xuICAgICAgICAgICAgdGFiLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfVEFCX0FDVElWRSk7XG4gICAgICAgICAgICB0YWIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmb2N1c0V2ZW50SGFuZGxlcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIFsuLi5wYW5lbHNdLmZvckVhY2goKHBhbmVsKSA9PiB7XG4gICAgICAgICAgICBwYW5lbC5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICdoaWRkZW4nKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9jdXNFdmVudEhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgYWN0aXZhdGVUYWIodGFyZ2V0LCBmYWxzZSk7XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGluaXRUYWJzID0gKCkgPT4ge1xuICAgIGNvbnN0IHRhYnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX1RBQlNfQ09OVEFJTkVSKTtcbiAgICBbLi4udGFic10uZm9yRWFjaCgodGFiQ29uYXRpbmVyKSA9PiB7XG4gICAgICAgIFRhYnModGFiQ29uYXRpbmVyKTtcbiAgICB9KTtcbn07XG4iLCIvKiFcbiogdGFiYmFibGUgNS4xLjJcbiogQGxpY2Vuc2UgTUlULCBodHRwczovL2dpdGh1Yi5jb20vZm9jdXMtdHJhcC90YWJiYWJsZS9ibG9iL21hc3Rlci9MSUNFTlNFXG4qL1xudmFyIGNhbmRpZGF0ZVNlbGVjdG9ycyA9IFsnaW5wdXQnLCAnc2VsZWN0JywgJ3RleHRhcmVhJywgJ2FbaHJlZl0nLCAnYnV0dG9uJywgJ1t0YWJpbmRleF0nLCAnYXVkaW9bY29udHJvbHNdJywgJ3ZpZGVvW2NvbnRyb2xzXScsICdbY29udGVudGVkaXRhYmxlXTpub3QoW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdKScsICdkZXRhaWxzPnN1bW1hcnknXTtcbnZhciBjYW5kaWRhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqL2NhbmRpZGF0ZVNlbGVjdG9ycy5qb2luKCcsJyk7XG52YXIgbWF0Y2hlcyA9IHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyA/IGZ1bmN0aW9uICgpIHt9IDogRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG5cbmZ1bmN0aW9uIHRhYmJhYmxlKGVsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcmVndWxhclRhYmJhYmxlcyA9IFtdO1xuICB2YXIgb3JkZXJlZFRhYmJhYmxlcyA9IFtdO1xuICB2YXIgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXMoZWwsIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlKTtcbiAgY2FuZGlkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChjYW5kaWRhdGUsIGkpIHtcbiAgICB2YXIgY2FuZGlkYXRlVGFiaW5kZXggPSBnZXRUYWJpbmRleChjYW5kaWRhdGUpO1xuXG4gICAgaWYgKGNhbmRpZGF0ZVRhYmluZGV4ID09PSAwKSB7XG4gICAgICByZWd1bGFyVGFiYmFibGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JkZXJlZFRhYmJhYmxlcy5wdXNoKHtcbiAgICAgICAgZG9jdW1lbnRPcmRlcjogaSxcbiAgICAgICAgdGFiSW5kZXg6IGNhbmRpZGF0ZVRhYmluZGV4LFxuICAgICAgICBub2RlOiBjYW5kaWRhdGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHZhciB0YWJiYWJsZU5vZGVzID0gb3JkZXJlZFRhYmJhYmxlcy5zb3J0KHNvcnRPcmRlcmVkVGFiYmFibGVzKS5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYS5ub2RlO1xuICB9KS5jb25jYXQocmVndWxhclRhYmJhYmxlcyk7XG4gIHJldHVybiB0YWJiYWJsZU5vZGVzO1xufVxuXG5mdW5jdGlvbiBmb2N1c2FibGUoZWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhlbCwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKTtcbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59XG5cbmZ1bmN0aW9uIGdldENhbmRpZGF0ZXMoZWwsIGluY2x1ZGVDb250YWluZXIsIGZpbHRlcikge1xuICB2YXIgY2FuZGlkYXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShlbC5xdWVyeVNlbGVjdG9yQWxsKGNhbmRpZGF0ZVNlbGVjdG9yKSk7XG5cbiAgaWYgKGluY2x1ZGVDb250YWluZXIgJiYgbWF0Y2hlcy5jYWxsKGVsLCBjYW5kaWRhdGVTZWxlY3RvcikpIHtcbiAgICBjYW5kaWRhdGVzLnVuc2hpZnQoZWwpO1xuICB9XG5cbiAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGZpbHRlcik7XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufVxuXG5mdW5jdGlvbiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUobm9kZSkge1xuICBpZiAoIWlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUobm9kZSkgfHwgaXNOb25UYWJiYWJsZVJhZGlvKG5vZGUpIHx8IGdldFRhYmluZGV4KG5vZGUpIDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1RhYmJhYmxlKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XG4gIH1cblxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG5vZGUpIHtcbiAgaWYgKG5vZGUuZGlzYWJsZWQgfHwgaXNIaWRkZW5JbnB1dChub2RlKSB8fCBpc0hpZGRlbihub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi9jYW5kaWRhdGVTZWxlY3RvcnMuY29uY2F0KCdpZnJhbWUnKS5qb2luKCcsJyk7XG5cbmZ1bmN0aW9uIGlzRm9jdXNhYmxlKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XG4gIH1cblxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShub2RlKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFiaW5kZXgobm9kZSkge1xuICB2YXIgdGFiaW5kZXhBdHRyID0gcGFyc2VJbnQobm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKTtcblxuICBpZiAoIWlzTmFOKHRhYmluZGV4QXR0cikpIHtcbiAgICByZXR1cm4gdGFiaW5kZXhBdHRyO1xuICB9IC8vIEJyb3dzZXJzIGRvIG5vdCByZXR1cm4gYHRhYkluZGV4YCBjb3JyZWN0bHkgZm9yIGNvbnRlbnRFZGl0YWJsZSBub2RlcztcbiAgLy8gc28gaWYgdGhleSBkb24ndCBoYXZlIGEgdGFiaW5kZXggYXR0cmlidXRlIHNwZWNpZmljYWxseSBzZXQsIGFzc3VtZSBpdCdzIDAuXG5cblxuICBpZiAoaXNDb250ZW50RWRpdGFibGUobm9kZSkpIHtcbiAgICByZXR1cm4gMDtcbiAgfSAvLyBpbiBDaHJvbWUsIDxhdWRpbyBjb250cm9scy8+IGFuZCA8dmlkZW8gY29udHJvbHMvPiBlbGVtZW50cyBnZXQgYSBkZWZhdWx0XG4gIC8vICBgdGFiSW5kZXhgIG9mIC0xIHdoZW4gdGhlICd0YWJpbmRleCcgYXR0cmlidXRlIGlzbid0IHNwZWNpZmllZCBpbiB0aGUgRE9NLFxuICAvLyAgeWV0IHRoZXkgYXJlIHN0aWxsIHBhcnQgb2YgdGhlIHJlZ3VsYXIgdGFiIG9yZGVyOyBpbiBGRiwgdGhleSBnZXQgYSBkZWZhdWx0XG4gIC8vICBgdGFiSW5kZXhgIG9mIDA7IHNpbmNlIENocm9tZSBzdGlsbCBwdXRzIHRob3NlIGVsZW1lbnRzIGluIHRoZSByZWd1bGFyIHRhYlxuICAvLyAgb3JkZXIsIGNvbnNpZGVyIHRoZWlyIHRhYiBpbmRleCB0byBiZSAwXG5cblxuICBpZiAoKG5vZGUubm9kZU5hbWUgPT09ICdBVURJTycgfHwgbm9kZS5ub2RlTmFtZSA9PT0gJ1ZJREVPJykgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBub2RlLnRhYkluZGV4O1xufVxuXG5mdW5jdGlvbiBzb3J0T3JkZXJlZFRhYmJhYmxlcyhhLCBiKSB7XG4gIHJldHVybiBhLnRhYkluZGV4ID09PSBiLnRhYkluZGV4ID8gYS5kb2N1bWVudE9yZGVyIC0gYi5kb2N1bWVudE9yZGVyIDogYS50YWJJbmRleCAtIGIudGFiSW5kZXg7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGVudEVkaXRhYmxlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZSc7XG59XG5cbmZ1bmN0aW9uIGlzSW5wdXQobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnSU5QVVQnO1xufVxuXG5mdW5jdGlvbiBpc0hpZGRlbklucHV0KG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAnaGlkZGVuJztcbn1cblxuZnVuY3Rpb24gaXNSYWRpbyhub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ3JhZGlvJztcbn1cblxuZnVuY3Rpb24gaXNOb25UYWJiYWJsZVJhZGlvKG5vZGUpIHtcbiAgcmV0dXJuIGlzUmFkaW8obm9kZSkgJiYgIWlzVGFiYmFibGVSYWRpbyhub2RlKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hlY2tlZFJhZGlvKG5vZGVzLCBmb3JtKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobm9kZXNbaV0uY2hlY2tlZCAmJiBub2Rlc1tpXS5mb3JtID09PSBmb3JtKSB7XG4gICAgICByZXR1cm4gbm9kZXNbaV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzVGFiYmFibGVSYWRpbyhub2RlKSB7XG4gIGlmICghbm9kZS5uYW1lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgcmFkaW9TY29wZSA9IG5vZGUuZm9ybSB8fCBub2RlLm93bmVyRG9jdW1lbnQ7XG4gIHZhciByYWRpb1NldCA9IHJhZGlvU2NvcGUucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cInJhZGlvXCJdW25hbWU9XCInICsgbm9kZS5uYW1lICsgJ1wiXScpO1xuICB2YXIgY2hlY2tlZCA9IGdldENoZWNrZWRSYWRpbyhyYWRpb1NldCwgbm9kZS5mb3JtKTtcbiAgcmV0dXJuICFjaGVja2VkIHx8IGNoZWNrZWQgPT09IG5vZGU7XG59XG5cbmZ1bmN0aW9uIGlzSGlkZGVuKG5vZGUpIHtcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUobm9kZSkudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicpIHJldHVybiB0cnVlO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKGdldENvbXB1dGVkU3R5bGUobm9kZSkuZGlzcGxheSA9PT0gJ25vbmUnKSByZXR1cm4gdHJ1ZTtcbiAgICBub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgeyBmb2N1c2FibGUsIGlzRm9jdXNhYmxlLCBpc1RhYmJhYmxlLCB0YWJiYWJsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIiwiLyohXG4qIGZvY3VzLXRyYXAgNi4xLjNcbiogQGxpY2Vuc2UgTUlULCBodHRwczovL2dpdGh1Yi5jb20vZm9jdXMtdHJhcC9mb2N1cy10cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiovXG5pbXBvcnQgeyBpc0ZvY3VzYWJsZSwgdGFiYmFibGUgfSBmcm9tICd0YWJiYWJsZSc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgYWN0aXZlRm9jdXNEZWxheTtcblxudmFyIGFjdGl2ZUZvY3VzVHJhcHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0cmFwUXVldWUgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBhY3RpdmF0ZVRyYXA6IGZ1bmN0aW9uIGFjdGl2YXRlVHJhcCh0cmFwKSB7XG4gICAgICBpZiAodHJhcFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGFjdGl2ZVRyYXAgPSB0cmFwUXVldWVbdHJhcFF1ZXVlLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChhY3RpdmVUcmFwICE9PSB0cmFwKSB7XG4gICAgICAgICAgYWN0aXZlVHJhcC5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmFwSW5kZXggPSB0cmFwUXVldWUuaW5kZXhPZih0cmFwKTtcblxuICAgICAgaWYgKHRyYXBJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdHJhcFF1ZXVlLnB1c2godHJhcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb3ZlIHRoaXMgZXhpc3RpbmcgdHJhcCB0byB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXG4gICAgICAgIHRyYXBRdWV1ZS5zcGxpY2UodHJhcEluZGV4LCAxKTtcbiAgICAgICAgdHJhcFF1ZXVlLnB1c2godHJhcCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWFjdGl2YXRlVHJhcDogZnVuY3Rpb24gZGVhY3RpdmF0ZVRyYXAodHJhcCkge1xuICAgICAgdmFyIHRyYXBJbmRleCA9IHRyYXBRdWV1ZS5pbmRleE9mKHRyYXApO1xuXG4gICAgICBpZiAodHJhcEluZGV4ICE9PSAtMSkge1xuICAgICAgICB0cmFwUXVldWUuc3BsaWNlKHRyYXBJbmRleCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFwUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICB0cmFwUXVldWVbdHJhcFF1ZXVlLmxlbmd0aCAtIDFdLnVucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZvY3VzVHJhcChlbGVtZW50LCB1c2VyT3B0aW9ucykge1xuICB2YXIgZG9jID0gZG9jdW1lbnQ7XG4gIHZhciBjb250YWluZXIgPSB0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgPyBkb2MucXVlcnlTZWxlY3RvcihlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgdmFyIGNvbmZpZyA9IF9vYmplY3RTcHJlYWQyKHtcbiAgICByZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZTogdHJ1ZSxcbiAgICBlc2NhcGVEZWFjdGl2YXRlczogdHJ1ZSxcbiAgICBkZWxheUluaXRpYWxGb2N1czogdHJ1ZVxuICB9LCB1c2VyT3B0aW9ucyk7XG5cbiAgdmFyIHN0YXRlID0ge1xuICAgIGZpcnN0VGFiYmFibGVOb2RlOiBudWxsLFxuICAgIGxhc3RUYWJiYWJsZU5vZGU6IG51bGwsXG4gICAgbm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uOiBudWxsLFxuICAgIG1vc3RSZWNlbnRseUZvY3VzZWROb2RlOiBudWxsLFxuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgcGF1c2VkOiBmYWxzZVxuICB9O1xuICB2YXIgdHJhcCA9IHtcbiAgICBhY3RpdmF0ZTogYWN0aXZhdGUsXG4gICAgZGVhY3RpdmF0ZTogZGVhY3RpdmF0ZSxcbiAgICBwYXVzZTogcGF1c2UsXG4gICAgdW5wYXVzZTogdW5wYXVzZVxuICB9O1xuICByZXR1cm4gdHJhcDtcblxuICBmdW5jdGlvbiBhY3RpdmF0ZShhY3RpdmF0ZU9wdGlvbnMpIHtcbiAgICBpZiAoc3RhdGUuYWN0aXZlKSByZXR1cm47XG4gICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgIHN0YXRlLmFjdGl2ZSA9IHRydWU7XG4gICAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gICAgc3RhdGUubm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gICAgdmFyIG9uQWN0aXZhdGUgPSBhY3RpdmF0ZU9wdGlvbnMgJiYgYWN0aXZhdGVPcHRpb25zLm9uQWN0aXZhdGUgPyBhY3RpdmF0ZU9wdGlvbnMub25BY3RpdmF0ZSA6IGNvbmZpZy5vbkFjdGl2YXRlO1xuXG4gICAgaWYgKG9uQWN0aXZhdGUpIHtcbiAgICAgIG9uQWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBhZGRMaXN0ZW5lcnMoKTtcbiAgICByZXR1cm4gdHJhcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYWN0aXZhdGUoZGVhY3RpdmF0ZU9wdGlvbnMpIHtcbiAgICBpZiAoIXN0YXRlLmFjdGl2ZSkgcmV0dXJuO1xuICAgIGNsZWFyVGltZW91dChhY3RpdmVGb2N1c0RlbGF5KTtcbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICBzdGF0ZS5hY3RpdmUgPSBmYWxzZTtcbiAgICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgICBhY3RpdmVGb2N1c1RyYXBzLmRlYWN0aXZhdGVUcmFwKHRyYXApO1xuICAgIHZhciBvbkRlYWN0aXZhdGUgPSBkZWFjdGl2YXRlT3B0aW9ucyAmJiBkZWFjdGl2YXRlT3B0aW9ucy5vbkRlYWN0aXZhdGUgIT09IHVuZGVmaW5lZCA/IGRlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZSA6IGNvbmZpZy5vbkRlYWN0aXZhdGU7XG5cbiAgICBpZiAob25EZWFjdGl2YXRlKSB7XG4gICAgICBvbkRlYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0dXJuRm9jdXMgPSBkZWFjdGl2YXRlT3B0aW9ucyAmJiBkZWFjdGl2YXRlT3B0aW9ucy5yZXR1cm5Gb2N1cyAhPT0gdW5kZWZpbmVkID8gZGVhY3RpdmF0ZU9wdGlvbnMucmV0dXJuRm9jdXMgOiBjb25maWcucmV0dXJuRm9jdXNPbkRlYWN0aXZhdGU7XG5cbiAgICBpZiAocmV0dXJuRm9jdXMpIHtcbiAgICAgIGRlbGF5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5Rm9jdXMoZ2V0UmV0dXJuRm9jdXNOb2RlKHN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbikpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBpZiAoc3RhdGUucGF1c2VkIHx8ICFzdGF0ZS5hY3RpdmUpIHJldHVybjtcbiAgICBzdGF0ZS5wYXVzZWQgPSB0cnVlO1xuICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5wYXVzZSgpIHtcbiAgICBpZiAoIXN0YXRlLnBhdXNlZCB8fCAhc3RhdGUuYWN0aXZlKSByZXR1cm47XG4gICAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgIGFkZExpc3RlbmVycygpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuICAgIGlmICghc3RhdGUuYWN0aXZlKSByZXR1cm47IC8vIFRoZXJlIGNhbiBiZSBvbmx5IG9uZSBsaXN0ZW5pbmcgZm9jdXMgdHJhcCBhdCBhIHRpbWVcblxuICAgIGFjdGl2ZUZvY3VzVHJhcHMuYWN0aXZhdGVUcmFwKHRyYXApOyAvLyBEZWxheSBlbnN1cmVzIHRoYXQgdGhlIGZvY3VzZWQgZWxlbWVudCBkb2Vzbid0IGNhcHR1cmUgdGhlIGV2ZW50XG4gICAgLy8gdGhhdCBjYXVzZWQgdGhlIGZvY3VzIHRyYXAgYWN0aXZhdGlvbi5cblxuICAgIGFjdGl2ZUZvY3VzRGVsYXkgPSBjb25maWcuZGVsYXlJbml0aWFsRm9jdXMgPyBkZWxheShmdW5jdGlvbiAoKSB7XG4gICAgICB0cnlGb2N1cyhnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgIH0pIDogdHJ5Rm9jdXMoZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGNoZWNrRm9jdXNJbiwgdHJ1ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGNoZWNrUG9pbnRlckRvd24sIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY2hlY2tQb2ludGVyRG93biwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2hlY2tDbGljaywge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjaGVja0tleSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKCFzdGF0ZS5hY3RpdmUpIHJldHVybjtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGNoZWNrRm9jdXNJbiwgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGNoZWNrUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2hlY2tDbGljaywgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjaGVja0tleSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROb2RlRm9yT3B0aW9uKG9wdGlvbk5hbWUpIHtcbiAgICB2YXIgb3B0aW9uVmFsdWUgPSBjb25maWdbb3B0aW9uTmFtZV07XG4gICAgdmFyIG5vZGUgPSBvcHRpb25WYWx1ZTtcblxuICAgIGlmICghb3B0aW9uVmFsdWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBub2RlID0gZG9jLnF1ZXJ5U2VsZWN0b3Iob3B0aW9uVmFsdWUpO1xuXG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgJyArIG9wdGlvbk5hbWUgKyAnYCByZWZlcnMgdG8gbm8ga25vd24gbm9kZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5vZGUgPSBvcHRpb25WYWx1ZSgpO1xuXG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgJyArIG9wdGlvbk5hbWUgKyAnYCBkaWQgbm90IHJldHVybiBhIG5vZGUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEluaXRpYWxGb2N1c05vZGUoKSB7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAoZ2V0Tm9kZUZvck9wdGlvbignaW5pdGlhbEZvY3VzJykgIT09IG51bGwpIHtcbiAgICAgIG5vZGUgPSBnZXROb2RlRm9yT3B0aW9uKCdpbml0aWFsRm9jdXMnKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5lci5jb250YWlucyhkb2MuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIG5vZGUgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IHN0YXRlLmZpcnN0VGFiYmFibGVOb2RlIHx8IGdldE5vZGVGb3JPcHRpb24oJ2ZhbGxiYWNrRm9jdXMnKTtcbiAgICB9XG5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91ciBmb2N1cy10cmFwIG5lZWRzIHRvIGhhdmUgYXQgbGVhc3Qgb25lIGZvY3VzYWJsZSBlbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSZXR1cm5Gb2N1c05vZGUocHJldmlvdXNBY3RpdmVFbGVtZW50KSB7XG4gICAgdmFyIG5vZGUgPSBnZXROb2RlRm9yT3B0aW9uKCdzZXRSZXR1cm5Gb2N1cycpO1xuICAgIHJldHVybiBub2RlID8gbm9kZSA6IHByZXZpb3VzQWN0aXZlRWxlbWVudDtcbiAgfSAvLyBUaGlzIG5lZWRzIHRvIGJlIGRvbmUgb24gbW91c2Vkb3duIGFuZCB0b3VjaHN0YXJ0IGluc3RlYWQgb2YgY2xpY2tcbiAgLy8gc28gdGhhdCBpdCBwcmVjZWRlcyB0aGUgZm9jdXMgZXZlbnQuXG5cblxuICBmdW5jdGlvbiBjaGVja1BvaW50ZXJEb3duKGUpIHtcbiAgICBpZiAoY29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgLy8gYWxsb3cgdGhlIGNsaWNrIHNpbmNlIGl0IG9jdXJyZWQgaW5zaWRlIHRoZSB0cmFwXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jbGlja091dHNpZGVEZWFjdGl2YXRlcykge1xuICAgICAgLy8gaW1tZWRpYXRlbHkgZGVhY3RpdmF0ZSB0aGUgdHJhcFxuICAgICAgZGVhY3RpdmF0ZSh7XG4gICAgICAgIC8vIGlmLCBvbiBkZWFjdGl2YXRpb24sIHdlIHNob3VsZCByZXR1cm4gZm9jdXMgdG8gdGhlIG5vZGUgb3JpZ2luYWxseS1mb2N1c2VkXG4gICAgICAgIC8vICB3aGVuIHRoZSB0cmFwIHdhcyBhY3RpdmF0ZWQgKG9yIHRoZSBjb25maWd1cmVkIGBzZXRSZXR1cm5Gb2N1c2Agbm9kZSksXG4gICAgICAgIC8vICB0aGVuIGFzc3VtZSBpdCdzIGFsc28gT0sgdG8gcmV0dXJuIGZvY3VzIHRvIHRoZSBvdXRzaWRlIG5vZGUgdGhhdCB3YXNcbiAgICAgICAgLy8gIGp1c3QgY2xpY2tlZCwgY2F1c2luZyBkZWFjdGl2YXRpb24sIGFzIGxvbmcgYXMgdGhhdCBub2RlIGlzIGZvY3VzYWJsZTtcbiAgICAgICAgLy8gIGlmIGl0IGlzbid0IGZvY3VzYWJsZSwgdGhlbiByZXR1cm4gZm9jdXMgdG8gdGhlIG9yaWdpbmFsIG5vZGUgZm9jdXNlZFxuICAgICAgICAvLyAgb24gYWN0aXZhdGlvbiAob3IgdGhlIGNvbmZpZ3VyZWQgYHNldFJldHVybkZvY3VzYCBub2RlKVxuICAgICAgICAvLyBOT1RFOiBieSBzZXR0aW5nIGByZXR1cm5Gb2N1czogZmFsc2VgLCBkZWFjdGl2YXRlKCkgd2lsbCBkbyBub3RoaW5nLFxuICAgICAgICAvLyAgd2hpY2ggd2lsbCByZXN1bHQgaW4gdGhlIG91dHNpZGUgY2xpY2sgc2V0dGluZyBmb2N1cyB0byB0aGUgbm9kZVxuICAgICAgICAvLyAgdGhhdCB3YXMgY2xpY2tlZCwgd2hldGhlciBpdCdzIGZvY3VzYWJsZSBvciBub3Q7IGJ5IHNldHRpbmdcbiAgICAgICAgLy8gIGByZXR1cm5Gb2N1czogdHJ1ZWAsIHdlJ2xsIGF0dGVtcHQgdG8gcmUtZm9jdXMgdGhlIG5vZGUgb3JpZ2luYWxseS1mb2N1c2VkXG4gICAgICAgIC8vICBvbiBhY3RpdmF0aW9uIChvciB0aGUgY29uZmlndXJlZCBgc2V0UmV0dXJuRm9jdXNgIG5vZGUpXG4gICAgICAgIHJldHVybkZvY3VzOiBjb25maWcucmV0dXJuRm9jdXNPbkRlYWN0aXZhdGUgJiYgIWlzRm9jdXNhYmxlKGUudGFyZ2V0KVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUaGlzIGlzIG5lZWRlZCBmb3IgbW9iaWxlIGRldmljZXMuXG4gICAgLy8gKElmIHdlJ2xsIG9ubHkgbGV0IGBjbGlja2AgZXZlbnRzIHRocm91Z2gsXG4gICAgLy8gdGhlbiBvbiBtb2JpbGUgdGhleSB3aWxsIGJlIGJsb2NrZWQgYW55d2F5cyBpZiBgdG91Y2hzdGFydGAgaXMgYmxvY2tlZC4pXG5cblxuICAgIGlmIChjb25maWcuYWxsb3dPdXRzaWRlQ2xpY2sgJiYgKHR5cGVvZiBjb25maWcuYWxsb3dPdXRzaWRlQ2xpY2sgPT09ICdib29sZWFuJyA/IGNvbmZpZy5hbGxvd091dHNpZGVDbGljayA6IGNvbmZpZy5hbGxvd091dHNpZGVDbGljayhlKSkpIHtcbiAgICAgIC8vIGFsbG93IHRoZSBjbGljayBvdXRzaWRlIHRoZSB0cmFwIHRvIHRha2UgcGxhY2VcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG90aGVyd2lzZSwgcHJldmVudCB0aGUgY2xpY2tcblxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9IC8vIEluIGNhc2UgZm9jdXMgZXNjYXBlcyB0aGUgdHJhcCBmb3Igc29tZSBzdHJhbmdlIHJlYXNvbiwgcHVsbCBpdCBiYWNrIGluLlxuXG5cbiAgZnVuY3Rpb24gY2hlY2tGb2N1c0luKGUpIHtcbiAgICAvLyBJbiBGaXJlZm94IHdoZW4geW91IFRhYiBvdXQgb2YgYW4gaWZyYW1lIHRoZSBEb2N1bWVudCBpcyBicmllZmx5IGZvY3VzZWQuXG4gICAgaWYgKGNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCkgfHwgZS50YXJnZXQgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgdHJ5Rm9jdXMoc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUgfHwgZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrS2V5KGUpIHtcbiAgICBpZiAoY29uZmlnLmVzY2FwZURlYWN0aXZhdGVzICE9PSBmYWxzZSAmJiBpc0VzY2FwZUV2ZW50KGUpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBkZWFjdGl2YXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzVGFiRXZlbnQoZSkpIHtcbiAgICAgIGNoZWNrVGFiKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSAvLyBIaWphY2sgVGFiIGV2ZW50cyBvbiB0aGUgZmlyc3QgYW5kIGxhc3QgZm9jdXNhYmxlIG5vZGVzIG9mIHRoZSB0cmFwLFxuICAvLyBpbiBvcmRlciB0byBwcmV2ZW50IGZvY3VzIGZyb20gZXNjYXBpbmcuIElmIGl0IGVzY2FwZXMgZm9yIGV2ZW4gYVxuICAvLyBtb21lbnQgaXQgY2FuIGVuZCB1cCBzY3JvbGxpbmcgdGhlIHBhZ2UgYW5kIGNhdXNpbmcgY29uZnVzaW9uIHNvIHdlXG4gIC8vIGtpbmQgb2YgbmVlZCB0byBjYXB0dXJlIHRoZSBhY3Rpb24gYXQgdGhlIGtleWRvd24gcGhhc2UuXG5cblxuICBmdW5jdGlvbiBjaGVja1RhYihlKSB7XG4gICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuXG4gICAgaWYgKGUuc2hpZnRLZXkgJiYgZS50YXJnZXQgPT09IHN0YXRlLmZpcnN0VGFiYmFibGVOb2RlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0cnlGb2N1cyhzdGF0ZS5sYXN0VGFiYmFibGVOb2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWUuc2hpZnRLZXkgJiYgZS50YXJnZXQgPT09IHN0YXRlLmxhc3RUYWJiYWJsZU5vZGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRyeUZvY3VzKHN0YXRlLmZpcnN0VGFiYmFibGVOb2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NsaWNrKGUpIHtcbiAgICBpZiAoY29uZmlnLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzKSByZXR1cm47XG4gICAgaWYgKGNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcblxuICAgIGlmIChjb25maWcuYWxsb3dPdXRzaWRlQ2xpY2sgJiYgKHR5cGVvZiBjb25maWcuYWxsb3dPdXRzaWRlQ2xpY2sgPT09ICdib29sZWFuJyA/IGNvbmZpZy5hbGxvd091dHNpZGVDbGljayA6IGNvbmZpZy5hbGxvd091dHNpZGVDbGljayhlKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKSB7XG4gICAgdmFyIHRhYmJhYmxlTm9kZXMgPSB0YWJiYWJsZShjb250YWluZXIpO1xuICAgIHN0YXRlLmZpcnN0VGFiYmFibGVOb2RlID0gdGFiYmFibGVOb2Rlc1swXSB8fCBnZXRJbml0aWFsRm9jdXNOb2RlKCk7XG4gICAgc3RhdGUubGFzdFRhYmJhYmxlTm9kZSA9IHRhYmJhYmxlTm9kZXNbdGFiYmFibGVOb2Rlcy5sZW5ndGggLSAxXSB8fCBnZXRJbml0aWFsRm9jdXNOb2RlKCk7XG4gIH1cblxuICBmdW5jdGlvbiB0cnlGb2N1cyhub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IGRvYy5hY3RpdmVFbGVtZW50KSByZXR1cm47XG5cbiAgICBpZiAoIW5vZGUgfHwgIW5vZGUuZm9jdXMpIHtcbiAgICAgIHRyeUZvY3VzKGdldEluaXRpYWxGb2N1c05vZGUoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiAhIWNvbmZpZy5wcmV2ZW50U2Nyb2xsXG4gICAgfSk7XG4gICAgc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUgPSBub2RlO1xuXG4gICAgaWYgKGlzU2VsZWN0YWJsZUlucHV0KG5vZGUpKSB7XG4gICAgICBub2RlLnNlbGVjdCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NlbGVjdGFibGVJbnB1dChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgdHlwZW9mIG5vZGUuc2VsZWN0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc0VzY2FwZUV2ZW50KGUpIHtcbiAgcmV0dXJuIGUua2V5ID09PSAnRXNjYXBlJyB8fCBlLmtleSA9PT0gJ0VzYycgfHwgZS5rZXlDb2RlID09PSAyNztcbn1cblxuZnVuY3Rpb24gaXNUYWJFdmVudChlKSB7XG4gIHJldHVybiBlLmtleSA9PT0gJ1RhYicgfHwgZS5rZXlDb2RlID09PSA5O1xufVxuXG5mdW5jdGlvbiBkZWxheShmbikge1xuICByZXR1cm4gc2V0VGltZW91dChmbiwgMCk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUZvY3VzVHJhcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtdHJhcC5lc20uanMubWFwXG4iLCJleHBvcnQgY29uc3Qgc2V0Rm9jdXNPbkZpcnN0RGVzY2VuZGFudCA9IChlbGVtZW50KSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmICh0cnlUb1NldEZvY3VzKGNoaWxkKSB8fCBzZXRGb2N1c09uRmlyc3REZXNjZW5kYW50KGNoaWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGNvbnN0IHNldEZvY3VzT25MYXN0RGVzY2VuZGFudCA9IChlbGVtZW50KSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmICh0cnlUb1NldEZvY3VzKGNoaWxkKSB8fCBzZXRGb2N1c09uTGFzdERlc2NlbmRhbnQoY2hpbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnQgY29uc3QgdHJ5VG9TZXRGb2N1cyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKCFpc0ZvY3VzYWJsZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnQ7XG59O1xuXG5leHBvcnQgY29uc3QgaXNGb2N1c2FibGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50LnRhYkluZGV4ID4gMCB8fCAoZWxlbWVudC50YWJJbmRleCA9PT0gMCAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiSW5kZXgnKSAhPT0gbnVsbCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZWxlbWVudC5ub2RlTmFtZSkge1xuICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgIHJldHVybiAhIWVsZW1lbnQuaHJlZiAmJiBlbGVtZW50LnJlbCAhPSAnaWdub3JlJztcbiAgICAgICAgY2FzZSAnSU5QVVQnOlxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZSAhPSAnaGlkZGVuJyAmJiBlbGVtZW50LnR5cGUgIT0gJ2ZpbGUnO1xuICAgICAgICBjYXNlICdCVVRUT04nOlxuICAgICAgICBjYXNlICdTRUxFQ1QnOlxuICAgICAgICBjYXNlICdURVhUQVJFQSc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuIiwiaW1wb3J0IHsgY3JlYXRlRm9jdXNUcmFwIH0gZnJvbSAnZm9jdXMtdHJhcCc7XG5pbXBvcnQgeyBzZXRGb2N1c09uRmlyc3REZXNjZW5kYW50IH0gZnJvbSAnLi91dGlscy9mb2N1cyc7XG5pbXBvcnQgeyBLRVlfQ09ERSB9IGZyb20gJy4vdXRpbHMva2V5cyc7XG5cbmNvbnN0IEJPRFlfT1BFTl9DTEFTUyA9ICdoYXMtbW9kYWwnO1xuY29uc3QgTU9EQUxfT1BFTl9DTEFTUyA9ICdtb2RhbC0tb3Blbic7XG5jb25zdCBEQVRBX01PREFMX1RPR0dMRSA9ICdkYXRhLXRvZ2dsZS1tb2RhbCc7XG5jb25zdCBEQVRBX01PREFMX0NMT1NFID0gJ2RhdGEtY2xvc2UtbW9kYWwnO1xuXG5jb25zdCBFVkVOVF9DTE9TRSA9ICdtb2RhbC5jbG9zZSc7XG5jb25zdCBFVkVOVF9PUEVOID0gJ21vZGFsLm9wZW4nO1xuXG5sZXQgYWN0aXZlTW9kYWwgPSBudWxsO1xuXG4vLyB0aGlzLmV2ZW50Q2xvc2UgPSBuZXcgRXZlbnQoRVZFTlRfQ0xPU0UpO1xuLy8gdGhpcy5ldmVudE9wZW4gPSBuZXcgRXZlbnQoRVZFTlRfT1BFTik7XG5cbmV4cG9ydCBjbGFzcyBNb2RhbCB7XG4gICAgY29uc3RydWN0b3IobW9kYWxJRCwgdG9nZ2xlcykge1xuICAgICAgICB0aGlzLm1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobW9kYWxJRCk7XG4gICAgICAgIHRoaXMuZm9jdXNUcmFwID0gY3JlYXRlRm9jdXNUcmFwKHRoaXMubW9kYWwpO1xuXG4gICAgICAgIGlmICh0b2dnbGVzICYmIHRvZ2dsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5pbml0VG9nZ2xlcyh0b2dnbGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXZlbnRDbG9zZSA9IG5ldyBFdmVudChFVkVOVF9DTE9TRSk7XG4gICAgICAgIHRoaXMuZXZlbnRPcGVuID0gbmV3IEV2ZW50KEVWRU5UX09QRU4pO1xuICAgIH1cblxuICAgIGluaXRUb2dnbGVzKHRvZ2dsZXMpIHtcbiAgICAgICAgWy4uLnRvZ2dsZXNdLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKCh0b2dnbGUpID0+IHtcbiAgICAgICAgICAgIHRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4gdGhpcy5zaG93TW9kYWwoZXZlbnQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2hvd01vZGFsKGV2ZW50KSB7XG4gICAgICAgIGFjdGl2ZU1vZGFsID0gdGhpcztcbiAgICAgICAgdGhpcy5hY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgdGhpcy5tb2RhbC5jbGFzc0xpc3QuYWRkKE1PREFMX09QRU5fQ0xBU1MpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoQk9EWV9PUEVOX0NMQVNTKTtcbiAgICAgICAgc2V0Rm9jdXNPbkZpcnN0RGVzY2VuZGFudCh0aGlzLm1vZGFsKTtcbiAgICAgICAgdGhpcy5mb2N1c1RyYXAuYWN0aXZhdGUoKTtcbiAgICAgICAgdGhpcy5oaWRlQWxsQ29udGVudEZvclNjcmVlblJlYWRlcnMoKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLm1vZGFsLmRpc3BhdGNoRXZlbnQodGhpcy5ldmVudE9wZW4pO1xuICAgIH1cblxuICAgIGNsb3NlTW9kYWwoZXZlbnQpIHtcbiAgICAgICAgYWN0aXZlTW9kYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKEJPRFlfT1BFTl9DTEFTUyk7XG4gICAgICAgIGFjdGl2ZU1vZGFsLm1vZGFsLmNsYXNzTGlzdC5yZW1vdmUoTU9EQUxfT1BFTl9DTEFTUyk7XG4gICAgICAgIGFjdGl2ZU1vZGFsLmZvY3VzVHJhcC5kZWFjdGl2YXRlKCk7XG4gICAgICAgIHRoaXMuc2hvd0FsbENvbnRlbnRGb3JTY3JlZW5SZWFkZXJzKCk7XG4gICAgICAgIGlmIChhY3RpdmVNb2RhbC5hY3RpdmVFbGVtZW50ICYmIGFjdGl2ZU1vZGFsLmFjdGl2ZUVsZW1lbnQuZm9jdXMpIHtcbiAgICAgICAgICAgIGFjdGl2ZU1vZGFsLmFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVNb2RhbC5tb2RhbC5kaXNwYXRjaEV2ZW50KGFjdGl2ZU1vZGFsLmV2ZW50Q2xvc2UpO1xuICAgICAgICBhY3RpdmVNb2RhbCA9IG51bGw7XG4gICAgfVxuXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMubW9kYWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlTW9kYWxDbGljayk7XG4gICAgICAgIHRoaXMubW9kYWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZU1vZGFsQ2xpY2spO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlVcEV2ZW50KTtcbiAgICB9XG5cbiAgICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5tb2RhbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVNb2RhbENsaWNrKTtcbiAgICAgICAgdGhpcy5tb2RhbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlTW9kYWxDbGljayk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50S2V5VXBFdmVudCk7XG4gICAgfVxuXG4gICAgaGFuZGxlRG9jdW1lbnRLZXlVcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfQ09ERS5FU0MpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgYWN0aXZlTW9kYWwuY2xvc2VNb2RhbChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVNb2RhbENsaWNrKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGNsb3NlQXR0ciA9IGBbJHtEQVRBX01PREFMX0NMT1NFfV1gO1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0Lmhhc0F0dHJpYnV0ZShjbG9zZUF0dHIpIHx8IGV2ZW50LnRhcmdldC5jbG9zZXN0KGNsb3NlQXR0cikpIHtcbiAgICAgICAgICAgIGFjdGl2ZU1vZGFsLmNsb3NlTW9kYWwoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGlkZUFsbENvbnRlbnRGb3JTY3JlZW5SZWFkZXJzKCkge1xuICAgICAgICBbLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbl0uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAhPT0gdGhpcy5tb2RhbCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2hvd0FsbENvbnRlbnRGb3JTY3JlZW5SZWFkZXJzKCkge1xuICAgICAgICBbLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbl0uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAhPT0gdGhpcy5tb2RhbCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBnZW5lcmF0ZU1vZGFsc1RvZ2dsZXNNYXAgPSAodG9nZ2xlcykgPT4ge1xuICAgIGNvbnN0IG1hcCA9IFtdO1xuXG4gICAgdG9nZ2xlcy5mb3JFYWNoKCh0b2dnbGUpID0+IHtcbiAgICAgICAgY29uc3QgbW9kYWxJRCA9IHRvZ2dsZS5nZXRBdHRyaWJ1dGUoREFUQV9NT0RBTF9UT0dHTEUpO1xuICAgICAgICBpZiAobWFwW21vZGFsSURdID09PSB1bmRlZmluZWQpIG1hcFttb2RhbElEXSA9IFtdO1xuICAgICAgICBtYXBbbW9kYWxJRF0ucHVzaCh0b2dnbGUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1hcDtcbn07XG5cbmV4cG9ydCBjb25zdCBpbml0TW9kYWxzID0gKCkgPT4ge1xuICAgIGNvbnN0IHRvZ2dsZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbJHtEQVRBX01PREFMX1RPR0dMRX1dYCk7XG4gICAgY29uc3QgbW9kYWxzVG9nZ2xlc01hcCA9IGdlbmVyYXRlTW9kYWxzVG9nZ2xlc01hcCh0b2dnbGVzKTtcblxuICAgIE9iamVjdC5rZXlzKG1vZGFsc1RvZ2dsZXNNYXApLmZvckVhY2goKG1vZGFsSUQpID0+IHtcbiAgICAgICAgY29uc3QgdG9nZ2xlcyA9IG1vZGFsc1RvZ2dsZXNNYXBbbW9kYWxJRF07XG4gICAgICAgIG5ldyBNb2RhbChtb2RhbElELCB0b2dnbGVzKTtcbiAgICB9KTtcbn07XG4iLCJjb25zdCBTRUxFQ1RPUl9JTlBVVF9XUkFQUEVSID0gJy5mb3JtLWZpZWxkJztcbmNvbnN0IFNFTEVDVE9SX0lOUFVUID0gJy5mb3JtLWZpZWxkX19pbnB1dCc7XG5jb25zdCBTRUxFQ1RPUl9FUlJPUiA9ICcuZm9ybS1maWVsZF9fZXJyb3InO1xuY29uc3QgQ0xBU1NfTEFCRUxfQUJPVkUgPSAnZm9ybS1maWVsZF9fbGFiZWwtLWFib3ZlJztcbmNvbnN0IENMQVNTX0lOVkFMSUQgPSAnZm9ybS1maWVsZC0taW52YWxpZCc7XG5cbmZ1bmN0aW9uIGhhbmRsZUlucHV0Q2hhbmdlRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgY2hhbmdlRmxvYXRMYWJlbFN0YXRlKHRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGNoYW5nZUZsb2F0TGFiZWxTdGF0ZShpbnB1dCkge1xuICAgIGNvbnN0IGxhYmVsID0gaW5wdXQubGFiZWxzID8gaW5wdXQubGFiZWxzWzBdIDogbnVsbDtcbiAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgY29uc3QgaXNMYWJlbEFib3ZlID0gaW5wdXQudmFsdWUgfHwgaW5wdXQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlzTGFiZWxBYm92ZSA/IGxhYmVsLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTEFCRUxfQUJPVkUpIDogbGFiZWwuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19MQUJFTF9BQk9WRSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVJlcXVpcmVkSW5wdXQoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0LnZhbHVlKSB7XG4gICAgICAgIHNldEludmFsaWRTdGF0ZShpbnB1dCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc2V0SW52YWxpZFN0YXRlKGlucHV0KSB7XG4gICAgY29uc3Qgd3JhcHBlciA9IGlucHV0LmNsb3Nlc3QoU0VMRUNUT1JfSU5QVVRfV1JBUFBFUik7XG4gICAgY29uc3QgZXJyb3IgPSB3cmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfRVJST1IpWzBdO1xuICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZChDTEFTU19JTlZBTElEKTtcbiAgICBlcnJvci5yZW1vdmVBdHRyaWJ1dGUoJ2hpZGRlbicpO1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIGVycm9yLmlkKTtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsIHRydWUpO1xufVxuXG5mdW5jdGlvbiByZXNldEludmFsaWRTdGF0ZShpbnB1dCkge1xuICAgIGNvbnN0IHdyYXBwZXIgPSBpbnB1dC5jbG9zZXN0KFNFTEVDVE9SX0lOUFVUX1dSQVBQRVIpO1xuICAgIGNvbnN0IGVycm9yID0gd3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0VSUk9SKVswXTtcbiAgICB3cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfSU5WQUxJRCk7XG4gICAgZXJyb3Iuc2V0QXR0cmlidXRlKCdoaWRkZW4nLCAnaGlkZGVuJyk7XG4gICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jyk7XG4gICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWludmFsaWQnKTtcbn1cblxuZnVuY3Rpb24gaW5pdElucHV0cygpIHtcbiAgICBjb25zdCBpbnB1dHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0lOUFVUKTtcbiAgICBbLi4uaW5wdXRzXS5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVJbnB1dENoYW5nZUV2ZW50KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaW5pdExvZ2luRm9ybSgpIHtcbiAgICBjb25zdCBsb2dpbk1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZ2luTW9kYWwnKTtcbiAgICBjb25zdCBsb2dpbkZvcm0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9naW5Gb3JtJyk7XG4gICAgY29uc3QgaW5wdXRzID0gbG9naW5Gb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfSU5QVVQpO1xuXG4gICAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGxvZ2luTW9kYWwuYWRkRXZlbnRMaXN0ZW5lcignbW9kYWwuY2xvc2UnLCAoZSkgPT4gcmVzZXRGb3JtSW52YWxpZFN0YXRlKCkpO1xuICAgICAgICBsb2dpbkZvcm0uYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0Jywgc3VibWl0Rm9ybSk7XG5cbiAgICAgICAgWy4uLmlucHV0c10uZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnRhcmdldC52YWx1ZSAmJiByZXNldEludmFsaWRTdGF0ZShlLnRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VibWl0Rm9ybShldmVudCkge1xuICAgICAgICBjb25zdCBpc0Zvcm1WYWxpZCA9IHZhbGlkYXRlRm9ybSgpO1xuXG4gICAgICAgIGlmIChpc0Zvcm1WYWxpZCkge1xuICAgICAgICAgICAgbG9naW5Nb2RhbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jbG9zZS1tb2RhbF0nKS5jbGljaygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGludmFsaWRGaWVsZHMgPSBsb2dpbkZvcm0ucXVlcnlTZWxlY3RvckFsbCgnW2FyaWEtaW52YWxpZF0nKTtcbiAgICAgICAgICAgIGludmFsaWRGaWVsZHNbMF0uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybSgpIHtcbiAgICAgICAgbGV0IGlzRm9ybVZhbGlkID0gdHJ1ZTtcbiAgICAgICAgWy4uLmlucHV0c10uZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0ZVJlcXVpcmVkSW5wdXQoaW5wdXQpO1xuICAgICAgICAgICAgIWlzVmFsaWQgJiYgKGlzRm9ybVZhbGlkID0gZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaXNGb3JtVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzZXRGb3JtSW52YWxpZFN0YXRlKCkge1xuICAgICAgICBbLi4uaW5wdXRzXS5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmVzZXRJbnZhbGlkU3RhdGUoaW5wdXQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGRFdmVudExpc3RlbmVycygpO1xufVxuXG5leHBvcnQgY29uc3QgaW5pdEZvcm1zID0gKCkgPT4ge1xuICAgIGluaXRJbnB1dHMoKTtcbiAgICBpbml0TG9naW5Gb3JtKCk7XG59O1xuIiwiaW1wb3J0IHsgaW5pdFRhYnMgfSBmcm9tICcuL3RhYnMnO1xuaW1wb3J0IHsgaW5pdE1vZGFscyB9IGZyb20gJy4vbW9kYWwnO1xuaW1wb3J0IHsgaW5pdEZvcm1zIH0gZnJvbSAnLi9mb3Jtcyc7XG5cbmNsYXNzIEFwcCB7XG4gICAgY29uc3RydWN0b3IoKSB7fVxuICAgIGluaXQoKSB7XG4gICAgICAgIGluaXRNb2RhbHMoKTtcbiAgICAgICAgaW5pdFRhYnMoKTtcbiAgICAgICAgaW5pdEZvcm1zKCk7XG4gICAgfVxufVxuXG5jb25zdCBhcHAgPSBuZXcgQXBwKCk7XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4gYXBwLmluaXQoKSk7XG4iLCJpbXBvcnQgJy4vc3R5bGVzL2luZGV4LnNjc3MnO1xuaW1wb3J0ICcuL3NjcmlwdHMvYXBwJztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")}]);